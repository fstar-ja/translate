Title         : F\* における検証されたプログラミング
Sub title     : チュートリアル
Heading Base  : 2
Author        : The F* Team
Affiliation   : MSR, MSR-Inria, Inria
Colorizer     : fstar
Package       : fullpage

.Comment      : replace=""
~CH           : .comment color=green author=CH
~CK           : .comment color=blue author=Chantal
~BB           : .comment color=purple author="Benjamin Beurdouche"
~NS           : .comment color=red author="Nik"
~MK           : .comment color=blue author=Markulf
~Todo         : .comment author="Todo"

~Remark       : font-style=italic padding-left=1em

~Exercise     : @h1-exercise=lower-case @h1-exercise label="@h1@h1-exercise"
                margin-left=1em
                before="[**練習問題 &label;: **]{margin-left=-1em}&br;"

~Answer       : replace="[回答]{.answer-link}&br;~Begin AnswerContent&nl;&source;&nl;~End AnswerContent&nl;"
                margin-top=-1em tight
~AnswerContent: border-style=solid border-width=1px border-color=black padding=0.5ex

~Code,~Pre : language=fstar
                replace=/([a-zA-Z])(\d)\b/\(\1\2|\1~\2~\)/g
                replace=/([a-zA-Z])_([\dnm])\b/\(\1_\2|\1~\2~\)/g
                replace=/_n1\b/\(_n1|~n-1~\)/g

~Fragment     : replace="```{.pre-fragment}&nl;&source;&nl;```&nl;&nl;[エディタに読み込む](&link;){float=right}&br;&nl;"
.pre-fragment : margin-bottom=0pt .framed padding=0.5ex

~ExerciseFragment : replace="~Begin Fragment {link=code/exercises/&exname;.fst}&nl;&source;&nl;~End Fragment&nl;"

~CodeFragment : replace="~Begin Fragment {link=code/&filename;?&label;&name;}&nl;&source;&nl;~End Fragment&nl;"


CatalinComment : replace="Can't understand why this doesn't work (it eats up the following solution. Also, why can't I write a proper <!-- comment here?"
~EmptyExerciseFragment : replace="~Begin Fragment {link=code/exercises/&exname;.fst}&nl;(* Write your code here *)&nl;~End Fragment&nl;"

~SolutionFragment : replace="~Begin Fragment {link=code/solutions/&exname;.fst}&nl;&source;&nl;~End Fragment&nl;"

~AnswerFragment : replace="~Begin Answer&nl;~Begin SolutionFragment {exname=&exname;}&nl;&source;&nl;~End SolutionFragment&nl;~End Answer&nl;"

~Code         : replace=/^:/\(:|\)/

<style>
.answer.view .answercontent,
.preview[data-view=full] .answer.view .answercontent,
.preview .answer .answercontent {
  display: block;
}
.answer .answercontent, .preview[data-view=full] .answer .answercontent {
  display:none;
}

.answer-link {
  cursor:pointer;
  text-decoration: underline;
  color: blue;
}
.answer.view .answer-link:after {
  content: "を隠す";
}
.answercontent p:first-child {
  margin-top: 0em;
}
.answercontent p:last-child {
  margin-bottom: 0em;
}
</style>

[TITLE]
[TOC]

<style>
.fstar .token.keyword { color: blue; }
.fstar .token.type.keyword.operator { color: teal; }
</style>

<!-- How to edit this document:
     1. Go to madoko.net in a web browser
     2. Select the folder icon in the top-left corner, then "Open ... (Alt-O)"
     3. Select the "GitHub" icon
     4. Authorize the Madoko application to access your GitHub repositories
     5. Open <github>/FStarLang/FStar/doc/tutorial/tutorial.mdk and start editing.
     6. Ctrl+S (or Synchronize from the folder tab) will bring up a dialog to
        commit and push this file to GitHub after merging with the latest changes there.

     For included code snippets:
     -- The snippets must be derived from files that are stored in the same subtree of the git repo
        i.e, all the samples should be in sub-directories of FStarLang/FStar/doc/tutorial/code

     Note: in this mode (i.e., github instead of dropbox), the document will not live update
           with the changes that anyone else may be making to the document concurrently. You
           will only see others' changes when you synchronize with github.

     If you use Emacs to edit this you can use the markdown-mode
     (http://jblevins.org/projects/markdown-mode/) for syntax highlighting.
-->

<!-- Daan's hints: -->
<!-- * Refer to Section [#sec-getstarted]. -->
<!-- * Use `Alt-Q` to reformat paragraphs. -->
<!-- * Drag&Drop a `.bib` file on the editor and start including citations. -->

(訳注: この日本語マニュアルは [Verified programming in F\*] の翻訳です。)

[Verified programming in F\*]: https://www.fstar-lang.org/tutorial/tutorial.html

# イントロダクション

F\* は検証指向のプログラミング言語で、[Microsoft Research], [MSR-Inria], [Inria] によって開発されています。
それは、型付で正格な関数型プログラミング言語である [ML] 族の言語の伝統を受け継いでいます。
けれども、その型システムは ML のそれよりも著しく豊かで、表明されて半自動的に検査される関数的な正確さの仕様を許します。
このチュートリアルは F\* における検証されたプログラミングの最初の体験を提供します。
論文とテクニカルレポートを含む F\* に関するより多くの情報が [F\* ウェブサイト] で見つかります。

[Microsoft Research]: http://research.microsoft.com/en-us
[MSR-Inria]: http://www.msr-inria.fr/
[Inria]: https://www.inria.fr/
[IMDEA Software]: http://software.imdea.org/
[ML]: https://en.wikipedia.org/wiki/ML_%28programming_language%29
[F\* ウェブサイト]: http://www.fstar-lang.org

もし ML 族の関数型プログラミング言語 (例: [OCaml], [F#], [Standard ML]) や [Haskell] に馴染みがあれば、それは役立つでしょう---もし馴染みがなくても、この文書で基本的な概念を簡単に説明します。より多くのバックグラウンドを知りたい場合には、Web 上に無料の有用な文書が多数あります。例えば、[TryF#], [F# for fun and profit], [Introduction to Caml], [Real World OCaml] などです。

[OCaml]: http://caml.inria.fr/ocaml/
[F#]: http://fsharp.org/
[Standard ML]: http://sml-family.org/
[Haskell]: https://www.haskell.org

[F# for fun and profit]: http://fsharpforfunandprofit.com/
[TryF#]: http://tryfsharp.org
[Introduction to Caml]: http://www.cs.jhu.edu/~scott/pl/lectures/caml-intro.html
[Real World OCaml]: https://realworldocaml.org/

F\* を試したりこのチュートリアルの検証の練習問題を解く最も簡単な方法は [オンライン F\* エディタ] を使ってウェブブラウザ上で直接動かすことです。
それぞの練習問題の本体中にある "エディタに読み込む" リンクをクリックすることで、それぞれの練習問題に必要なボイラープレートコードをオンラインエディタに読み込むことができます。
それぞれの練習問題でのあなた進捗はウェブブラウザのローカルストレージに保存されるので、(例えばウェブブラウザがクラッシュなどしても) 後であなたのコードを復帰できます。
(訳注: この文書では上記の [オンライン F\* エディタ] との連携は使えません。"エディタに読み込む" リンクをクリックすると、相当するソースコードをダウンロードできます。)

[オンライン F\* エディタ]: https://www.fstar-lang.org/run.php

また F\* をローカルのマシンにインストールしてこの練習問題を解くこともできます。
F\* はオープンソースでクロスプラットフォームです。
Windows, Linux, MacOS X 向けの [バイナリパッケージ] をダウンロードでき、またこれらの [手順] を用いて [github 上のソースコード] から F\* をコンパイルできます。

[バイナリパッケージ]: https://github.com/FStarLang/FStar/releases
[github 上のソースコード]: http://github.com/FStarLang/FStar
[手順]: https://github.com/FStarLang/FStar/blob/master/INSTALL.md

お好きなテキストエディタを使って F\* コードを編集できます。
そして [Emacs], [Atom], [Vim] には F\* を特別にサポートする拡張があり、シンタックスハイライトやインタラクティブな開発ができます。
[エディタのサポート] の詳細は [F\* wiki] を参照してください。

[Emacs]: https://github.com/FStarLang/fstar-mode.el
[Atom]: https://github.com/FStarLang/fstar-interactive
[Vim]: https://github.com/FStarLang/VimFStar
[エディタのサポート]: https://github.com/FStarLang/FStar/wiki/Editor-support-for-F*
[F\* wiki]: https://github.com/FStarLang/FStar/wiki

デフォルトでは F\* は入力されたコードを検証するだけで、**それを実行しません**。
F\* コードを実行するためには、OCaml や F# にエクストラクトし、OCaml や F# コンパイラを使ってコンパイルする必要があります。
[F\* コード実行] の詳細は [F\* wiki] を参照してください。

[F\* コード実行]: https://github.com/FStarLang/FStar/wiki/Executing-F*-code

<!-- CH: TODO: add a chapter on extraction to tutorial -->

<!-- CH: this is just distraction
**A note on compatibility with F\#**: The syntax of F\* and F\#
overlap on a common subset. In fact, the F\* compiler is currently
programmed entirely in this intersection. Aside from this, the
languages and their implementations are entirely distinct. In this
tutorial, we will use the full syntax of F\*, even when it is possible
to express the same program in the fragment shared with F\#. The F\*
compiler sources are a good resource to turn to when trying to figure
out the syntax of this shared fragment.
-->

<!-- # Getting started  { #sec-getstarted } -->

## はじめての F\* プログラム: アクセスコントロールの単純なモデル {#sec-access-control}

ファイルに対するアクセスコントロールの単純なモデルからはじめましょう。
この中で、一般的な関数型プログラミング由来のいくつかの基本的なコンセプトと、いくつかの F\* 固有の機能を見ることになるでしょう。

ファイルの単純なアクセスコントロールをモデル化したいとしましょう---あるファイルは読み書き可能で、一方で他のファイルはアクセスできません。
それぞれのファイルに対する権限を表わすポリシーを作り、このポリシーに照らしてプログラムのファイルアクセスのパターンをチェックし、アクセスできないファイルが決っして間違ってアクセスされてないことを静的に保証したいのです。

このシナリオでのモデル (これは後の章でより現実的にします) は3つの簡単なステップで進展します。

  1. 単純な純粋関数を使ってポリシーを定義します。


  2. プログラムにおけるセキュリティセンシティブなプリミティブを特定し、それらをポリシーを使って保護します。


  3. プログラムの残りを書きます。ポリシーで保護されたプリミティブは決っして不適切にアクセスされないことを F\* の型検査器は静的に検証することを保証されます。


### ポリシーを定義する { #sec-policy }

F\* の構文は OCaml 構文と F\# の non-light 構文に基づいています。
F\* プログラムは数個のモジュールで構成されます。
それぞれのモジュールはそのモジュールの名前を定義する `module` 宣言ではじまります。
その本体は多数の定義と任意に 'main' 式を含みます。

ここでは2つのモジュールがあります: 1つは `FileName` と呼ばれ、もう1つは (Access-Control Lists を表わす) `ACLs` と呼ばれます:

~ Fragment {link="code/exercises/ex1a-safe-read-write.fst"}
[INCLUDE=code/exercises/ex1a-safe-read-write.fst:ACLs]
~

`FileName` モジュールは型シノニムを定義します: `:filename` をモデル化するのに `:string` を使えます。
`ACLs` モジュールははじめに `FileName` モジュールを `open` するので、その型シノニムは直接使えるようになります。(そうしない場合、長いフル修飾された名前: `:FileName.filename` で呼び出す必要があります。)

その後 `ACLs` は2つのブール関数としてセキュリティポリシーを定義します:
`canWrite` と `canRead` です:
`canWrite` 関数はその引数 `f` を *パターンマッチ式* を使って検査します:
`f="demo/tempfile"` であったらブール `true` を返し、そうでなければ `false` を返します。
関数 `canRead` も同様です---ファイルが書き込み可能もしくは `"demo/README"` ファイルであったなら、そのファイルは読み出し可能です。

### ポリシーをファイルアクセスプリミティブと結びつける

ポリシーを強制するためには、ファイルを読み書きを実際に実装するプログラムのプリミティブにポリシーを接続する必要があります。

F\* は別に実装された外部のモジュールへのインターフェイスを指定する機能を提供しています。
例えば、ファイルの入出力操作は OS によって実装されていますが、例えば .NET や OCaml のような下層のフレームワークを通じて F\* プログラム中で有効にできます。
次のように、そのフレームワークによって提供された単純なインターフェイスを表現できます:

~ Fragment {link=code/exercises/ex1a-safe-read-write.fst}
[INCLUDE=code/exercises/ex1a-safe-read-write.fst:FileIO]
~

ここでは、`ACLs` モジュールを使う `FileIO` と呼ばれる *インターフェイス* を定義しました。
より重要なことは、`FileIO` は2つの関数 `read` と `write` を提供し、それらはおそらく相当するファイル操作を実装しています。

`assume val` 表記を使って、`FileIO` が `read` と `write` 操作 (それらは *値* です) を提供すると *宣言* しましたが、ここではそれらの値を *定義していません* ---それらは外部のモジュールで提供されます。
`assume val` の使用はC言語や他のプログラミング言語の `extern`{language=csharp} キーワードと良く似ています。

`extern`{language=csharp} を使って値を宣言するとき、その型シグニチャも提供します。

* `read` の型は、それが引数 `f` に `canRead f` が `true` に評価されるような `filename` を取り、`string` 型の結果を返す関数であると主張しています。
  したがって型検査器は、引数に対して述語 `canRead` が静的に証明されないようなどのような `read` 呼び出しも防止します。

* `write` の型は、それが次のような2引数の関数です:
  1つ目は `canWrite f` が `true` に評価されるような `filename` `f` です;
  2つ目は `string` で、そのデータはファイル `f` に書き込まれます。
  `write` 関数は `unit` を返し、それはおおざっぱにC言語の `void` 型に似ています。
  型 `unit` は唯一の値を持ち、`()` と書きます。

もちろん、これらの宣言の重要な点は型シグニチャにおける `canRead` と `canWrite` の使用です。
それらによってセキュリティセンシティブな関数の型をポリシーに接続できます。

### プログラムを書き、そのセキュリティを検証する

コード片がアクセスコントロールポリシーに従っていることをチェックするのは退屈でエラーしやすいでしょう。
たとえそれぞれのアクセスがセキュリティチェックで保護されていたとしても、どうすればそれぞれのチェックが適切であることを確認できるでしょうか？
F\* を使うことで、この種のコードレビューを自動化できます。

ここではいくらか単純な信頼できないクライアントコードを示します。
このコードは共通のファイル名を定義する `FileIO` を使い、それから複数のファイルを読み書きする `staticChecking` と呼ばれる関数を使います。

~ Fragment {link=code/exercises/ex1a-safe-read-write.fst}
[INCLUDE=code/exercises/ex1a-safe-read-write.fst:UntrustedClientCode]

[INCLUDE=code/exercises/ex1a-safe-read-write.fst:StaticChecking]
~

型検査器は、この信頼できないコードがセキュリティポリシーと共にコンパイルされるされることを静的に保証します。
`tmp` と `readme` の読み出しと `tmp` への書き込みはポリシーで許されているので、このプログラムの型検査は成功します。
一方、`password` ファイルを読んだり `"junk"` を書き込む行のコメントを外すと、F\* 型検査器は `passwd` ファイルがそれぞれ型 `:f:filename{canRead f}` や `:f:filename{canWrite f}` を持たないことを訴えます。
例えば、この `write` のコメントを外すと、次のようなエラーメッセージが得られます:

<!-- fstar.exe code/exercises/ex1a-safe-read-write.fst -->
``` {language=""}
Error ex1a-safe-read-write.fst(38,2-47,5): The following problems were found:
	Subtyping check failed; expected type f:filename{(canWrite f)};
    got type string (ex1a-safe-read-write.fst(43,17-43,23))
```
<!-- CH: It would be nice if at some point such error messages were
     "real", coming directly from the type-checker without being
     touched by human hands. -->

このチュートリアルを読み進めることで、このメッセージの意味がより理解できるようになるでしょう。
ここでは、F\* が `canWrite passwd` が `true` に評価されると期待しているのに、この場合成立しないことを意味しています。

上記の `staticChecking` 関数は、セキュリティポリシーを指定し、ポリシーの完全で正確な調停を型検査を通じて静的に強制するのにどのように F\* を使うことができるかを説明しています。
ここで、ポリシーのチェックは全て静的に行なわれる必要はなく、プログラマが追加した動的なチェックが型システムによって検討されることを説明します。
具体的には、ポリシーを調べてポリシーが許可するときだけ `read` を行ない、そうでなければ例外を発生させる `checkedRead` 関数を実装してみましょう。
~ Fragment {link=code/exercises/ex1a-safe-read-write.fst}
[INCLUDE=code/exercises/ex1a-safe-read-write.fst:CheckedRead]
~
`checkRead` 型は入力ファイル `f` の条件を強制していないことに注意してください。
`ACLs.canRead f` チェックが成功したなら、型検査器は `FileIO.read f` 安全であることがわかります。

~Exercise
ファイル名 `f` と文字列 `s` を引数に取り、ポリシーをチェックしてファイル `f` が書き込み可能か確認し、書き込み可能な場合のみ `s` を `f` に書き込む `checkedWrite` という名前の関数を書いてください。
そのファイルが書き込み可能でなかったら、`checkedWrite` は例外を発生させます。
`checkedRead` に関して事前条件はありません。
~~ ExerciseFragment {exname=ex1a-safe-read-write}
[INCLUDE=code/exercises/ex1a-safe-read-write.fst:CheckedWriteType]
~~
~~ Answer
~~~ SolutionFragment {exname=ex1a-safe-read-write}
[INCLUDE=code/solutions/ex1a-safe-read-write.fst:CheckedWrite]
~~~
~~
~
これで、`staticChecking` の `read` と `write` を `checkedRead` と `checkedWrite` で置き換えることで、`passwd` へのアクセスが型付けできます。
~ ExerciseFragment {exname=ex1a-safe-read-write}
[INCLUDE=code/exercises/ex1a-safe-read-write.fst:DynamicChecking]
~
`checkedRead` と `checkedWrite` は F\* によってコンパイル時にあらかじめ行なわれたのと同じチェックを実行時に延期させ、それらのチェックが成功した場合のみその入出力アクションを行なうため、これは安全です。

# 基本: 型と作用

全てを知らされていませんでしたが、F\* 独特の機能のいくつかを最初の例で既に見てきました。
より詳細に見てみましょう。

## リファインメント型

F\* の1つの特徴的な機能はリファインメント型の使用です。
この機能を既に2度使いました。
例えば、型 `:f:filename{canRead f}` は型 `:filename` の *リファインメント* です。
`:filename` 値のサブセットのみがこの型、すなわち述語 `canRead` を満たす型を持つので、それはリファインメントなのです。
`FileIO.write` の型のリファインメントも同様です。
伝統的な ML 族の言語では、このような型は表現できません。

一般に、F\* におけるリファインメント型は `:x:t{phi(x)}` の形を取ります。
このときそれは型 `:t` のリファインメントで、その要素 `x` は式 `:phi(x)` を満たします。
今のところ、`:phi(x)` は式を評価すると得られる純粋なブールであると考えることができます。
詳細には [#sec-bool-versus-type] で、より一般化します。

## 推論された型と計算のための作用

~CH
Too much back and forth about type and effect _inference_ seems to be
obscuring the explanation. How about:
(1) effects (just remove every reference to inference,
  e.g. replace "is inferred to have effect E" with "has effect E"),
(2) function types,
(3) (type and) effect inference
~

`canRead` や `canWrite` のような関数の型を書きませんでしたが、(ML 族の他の言語と同様に) F\* は (その型が正しいなら) プログラムの型を推論します。
けれども、F\* によって推論される型は ML で表現される型よりもより詳細です。
例えば、型推論に加えて、F\* は式の *副作用* (例: 例外、状態など) も推論します。

例えば、ML では `(canRead "foo.txt")` は型 `:bool` を持つと推論されます。
けれども、F\* では `(canRead "foo.txt" : Tot bool)` と推論します。
これは `canRead "foo.txt"` 純粋で全域な式で、常にブールに評価されることを示しています。
ついでに言うと、型と作用 `:Tot t` を持つと推論された式は、(コンピュータが十分なリソースを持っていれば) `:t` で型付けされた結果に評価されることが保証されます。
そしてこの式は無限ループに入らず、プログラムの状態を読み書きせず、例外を発生せず、入出力を行なわず、その他の作用を引き起こしません。

一方、`(FileIO.read "foo.txt")` のような式は型と作用 `:ML string` を持つと推論されます。
これはこの項が任意の作用 (ループ、入出力、例外発生、ヒープの変更など) を持つ可能性があり、けれどももしそれがリターンしたなら、常に文字列を返すことを意味しています。
作用の生 `:ML` はデフォルト、つまり全ての ML プログラムの暗黙の作用を表わしています。

`:Tot` と `:ML` は取りうる作用の全てではありません。
それ以外に次のような作用があります:

* `:Dv`、分岐を共なう計算の作用
* `:ST`、分岐やヒープ中の参照の読み書きや確保を共なう計算の作用
* `:Exn`、分岐や例外を共なう計算の作用

~CH
Should we add Ghost to the list of effects or would that be too
confusing at this point?
~

作用 `:{Tot, Dv, ST, Exn, ML}` は束として配置されます。
`:Tot` は (その他全ての作用より下位である) 下限に、`:ML` は (その他全ての作用より上位である) 上限に配置され、`:ST` と `:Exn` は関係がありません。
これは特定の作用を共なう計算が、作用の順序においてその作用より大きいその他の作用を持つと扱えることを意味しています---私達はこの機能を *サブ作用* と呼んでいます。

実際、F\* では、独自の作用と作用の順序を構成でき、F\* にそれらの作用を推論させることができます---しかしそれはより高度な機能で、このチュートリアルの範囲外です。
~CH
Previous claim seems too strong to me. It misses the point that F\*
effects are primitive and fixed, and in a way the lattice of effects
is also fixed (the powerset of effects), one can only choose which
points in this fixed lattice one finds interesting. So at the level of
detail things were explain so far, this claim seems wrong.
Am I missing anything?
~

~NS
Yes, effects are primitive. But, the lattice is not fixed nor is the powerset,
since the effects themselves can be arbitrarily fine-grained. For example,
you can take {Pure, Div, RD, WR, ALLOC, ST, EXN, ALL}. You could also
split RD/WR into very precise ones, recording a subset of the state that
may be written, etc.
~

~CH
I think the word effect is overloaded and this makes this discussion
(and the text above) a bit confusing. There is an intuitive notion of
effect as in non-termination, exceptions, state (there are very few
such effects and they are all primitive) and there is the technical
notion of an effect in F\* (which includes things like a wp and can be
a lot more fine-grained; these are the things that are actually
configurable). The explanation above seems to start with the first
point of view and end up with the second.
~

今後は (例えば `:Tot` が作用で `:int` が結果の型である `:Tot int` のような) 型と作用のペアを、単に型と呼ぶことにします。<!-- unused: , or sometimes as a *computation* type -->.

## 関数型

F\* は関数型言語で、関数は関数型が割り当てられた第一級の値です。
例えば ML では、ある整数が正であるか判別する関数には型 `:int -> bool` が与えられます。
すなわち、この関数は整数を引数に取り、ブールを結果として生成します。
同様に、整数の最大値を計算する関数 `max` には型 `:int -> int -> int` が与えられます。
すなわち、この関数は2つの整数を取り、1つの整数を生成します。
F\* における関数型はより詳細で、引数と返り値の型だけでなく、関数本体の作用も捕捉します。
このように、全ての関数値は `:t_1 -> ... -> t_n -> E t` のような型を持ちます。
このとき `:t_1 .. t_n` は引数それぞれの型で;
`:E` は関数本体の作用;
そして `:t` はその結果の型です。
(*上級者への注意: これは作用でインデックスされた依存した関数に一般化されます。)
F\* では、上記の純粋関数には作用 `Tot` を使った型が与えられます:
```
val is_positive : int -> Tot bool
let is_positive i = i > 0

val max : int -> int -> Tot int
let max i1 i2 = if i1 > i2 then i1 else i2
```
ファイルの内容を読むような、純粋でない関数には同様に作用が与えられます:
```
val read : filename -> ML string
```

(OCaml や F\# と同様に、Haskell や Coq と異なり) F\* は _値渡し_ の関数型言語で、関数の引数はその関数に渡される前に、完全に評価されて値になります。
値は (直接の) 作用を持たないので、関数の引数の型は作用の注釈を持ちません。
一方で、関数の本体は非自明な計算を行なうかもしれません。
そのため上記で説明したように、その結果は常に型と作用の両方で与えられます。

~Exercise
上記で見てきたように、定義が予想される型を持つことを F\* にチェックさせるために `val` を使います。
`canRead` と `canWrite` について [#sec-policy] から予測される型を書いて、それをチェックするよう F\* に支持してください。
~~ ExerciseFragment {exname=ex2a-can-read-write-types}
[INCLUDE=code/exercises/ex2a-can-read-write-types.fst]
~~

~~ AnswerFragment {exname=ex2a-can-read-write-types}
val canRead: filename -> Tot bool
val canWrite: filename -> Tot bool
~~
~

### デフォルトの作用は `ML`

注釈がない場合、F\* は、入出力を行なうかもしれないか、停止しないかもしれない関数を、作用 `:ML` を持つと (ときに保守的に) 推論します。
そのため、下記どちらの関数も型 `:(int -> ML int)` を持つと推論されます。
(注意: 再帰関数は ML 族の言語では `let rec` で定義されます。)

    let hello_incr i = IO.print_string "hello"; i + 1
    let rec loop i = i + loop (i - 1)

もし明示的な注釈を与えると、これらの関数により正確な型を割り当てることができます:

    val hello_incr i : int -> IO int
    let hello_incr i = IO.print_string "hello"; i + 1

    val loop : int -> Dv int
    let rec loop i = i + loop (i - 1)

プログラムを ML から F\* に移植するために、私達はデフォルトの作用を `ML` に選び、通常はそれを書かずに済むようにしました。
そのため `hello_incr` と `loop` を表わす通常の ML シグニチャを以下の示すように書くことができます。
これはより明示的な `:(int -> ML int)` と単に同義です。

    val hello_incr: int -> int
    val loop: int -> int

~CH
This seems like the right place to explain higher-order functions.
Could start by explaining currying, then functions taking functions
as arguments (e.g. sorting).
~

### 計算する関数

_もし関数型プログラミングの初学者なら、はじめて読む際にこの章を飛ばしてください。_

ときに、なんらかの計算を行なった後に関数を返すことが有用です。
例えば、次の関数は新しいカウンタを作り、それを `init` で初期化します。

    let new_counter init =
      let c = ST.alloc init in
      fun () -> c := !c + 1; !c

F\* は `new_counter` が型 `:int -> ST (unit -> ST int)` を持つと推論します。
型によるとこの関数は、整数が与えられ、参照を読み書きもしくは確保するかもしれず、それから `:unit -> ST unit` 型の関数を返します。
この型を書いて、F\* にチェックさせることができます;
もしくはサブ作用を使って、下記のように型を書いて `new_counter` が上手く型付けできることを F\* にチェックさせることもできます。

    val new_counter: int -> ML (unit -> int)

上記の型、`:int -> ML (unit -> ML int)` の短縮形は、`:int -> unit -> int` と同じでは *ありません* 。
注意してください。
後者は `:int -> Tot (unit -> ML int)` の短縮形です。

# 整数を扱う関数の最初の証明 { #sec-firstproofs }

<!--
Main ideas in this section:

* F\* provides several ways of specifying and statically verifying
  properties of programs:
  - assertions
  - refinement types
  - predicate transformers (e.g. Lemma)
* F\* types allow for two complementary verification styles:
  - intrinsic vs extrinsic (ie. at definition time vs. after the fact)
-->

アクセスコントロールリストの最初の例では、どのように F\* の型システムがセキュリティ属性の自動的な検査に使うことができるか示しました。
けれども、より興味深いセキュリティに関連したプログラミングと検証を行なう前に、F\* の基礎についてより理解を深める必要があります。
ここで戻って、整数を扱う単純な関数のプログラミングと性質の証明を見てみましょう。


## 静的に検査される表明

~CH
These example assertions are horrible because
(1) they are in fact lemmas, while that's usually not the case
    for assertions and
(2) they don't really work in F\*, which doesn't support top level assertions.
How can we fix this?
We could introduce asserts as just a way to check facts in lemmas
or as a way to check facts within (effectful) code.
~

~NS
I don't see the distinction you're making between lemmas and assertions.
You can write `let test = assert (max 0 1 = 1)`. Is that so bad as to be horrible?
~

~CH
(1) In almost about any other language asserts are used to check
_intensional_ properties of (usually stateful) programs by decorating
code. Here you use assert to prove some lemmas (extensional
properties) after the fact. Moreover, this doesn't even seem like the
recommended way to prove lemmas in F\*, given that we have better
support for this described below.
(2) How is someone reading this tutorial supposed to find out that
they need to add a let? Why not make the tutorial match reality
by allowing top level asserts in F\* or by adding lets in the tutorial?
Generally we should strive to make all the code in this tutorial be valid F\*
code that we can directly load in the editor.
~

F\* のコードにおける性質を証明する1つの方法は表明を書くことです。

    let a = assert (max 0 1 = 1)

最初の表明は `max` に関する明らかな性質です。
別の言語で `assert` と呼ばれる構成物を見たことがあるかもしれません---一般に、そのような `assert` はコードの性質を *実行時に* 検査するために使われ、その表明条件が `true` でない場合には表明に失敗した例外が発生します。

F\* では、表明は実行時の意味を持ちません。
その代わりに、F\* はその表明条件が真であることを静的に証明しようとします。
そのため実行時に検査されたとしても決っして失敗しません。

この場合、`max 0 1 = 1` の証明は簡単です。
裏で F\* は `max` の定義と表明された性質を [Z3] と呼ばれる定理証明器に渡して、その性質を自動的に証明します。

[Z3]: http://z3.codeplex.com/

`max` のより一般的な性質を表明して、自動的に検査することができます。例えば次のようになります:

    let a = assert (forall x y. max x y >= x
                     && max x y >= y
                     && (max x y = x || max x y = y))

## 階乗とフィボナッチ関数

階乗関数を見てみましょう:

    let rec factorial n = if n = 0 then 1 else n * factorial (n - 1)

以前解説した通り、注釈がない場合、F\* はこの関数の型を `:int -> int` であると推論します。これは `:int -> ML int` の短縮形です---これは F\* がこの `factorial` が (もしくはどのような再帰関数が) 純粋で全域関数であることを自動的に証明しようとしないことを意味しています。
実際、階乗は任意の整数に対して全域関数ではないのです!
`factorial (-1)` を考えてみましょう。

~ Remark
F\* の `:int` 型は任意精度の整数を表わします。
~

けれども、`factorial` 関数は非負の整数については全域関数です。
これを実際に書いた場合、検査を F\* に支持できます:

    val factorial: x:int{x>=0} -> Tot int

上記の行にはいくつかの主張があります:

* `factorial` は値です ('`val factorial`' 部分で主張しています)

* それは *関数* です (矢印型 '`->`' で主張しています)

* それは `0` 以上の整数 `x` に対してのみ適用できます (リファインメント型 '`x:int{x>=0}`' で主張しています)

* `x` に適用されると、それは常に停止し、作用を持たず ('`:Tot`' 部分で主張しています)、そして整数を返します (返り値の型 '`:int`' で主張しています)

このように書くと、F\* は `factorial` がこれら全ての性質を満たすことを自動的に証明します。
もちろん、証明における主な興味は `x` が非負の場合に `factorial x` が実際に停止するかどうかです。
これがどのように行なわれるかその詳細は章 [#sec-termination] で議論しますが、この場合 F\* が非負な数値に対する全ての再帰的な呼び出しは以前の呼び出しでの引数より厳密に小さくなることを証明できると理解すれば十分です。
これは無限に続くかない (最終的に基底ケース `0` に収束する) ので、F\* は `factorial` の型に関する主張に同意します。

非負な整数 (もしくは自然数) の型はありふれたもので、それは省略して定義できます。
(実際、F\* では標準の prelude 中でこれは既に定義済みです。)

    type nat = x:int{x>=0}

~ Exercise
`factorial` には他にどのような型を与えられるでしょうか？
それらを書いて、F\* が同意するかどうか確認してください。
それらの型の意味を言葉で表現してください。
~~ ExerciseFragment {exname=ex3a-factorial-types}
[INCLUDE=code/exercises/ex3a-factorial-types.fst:FactorialTypes]
~~
~~ Answer
`factorial` に対して多くの正しい型があります。
次はその内のいくつかです:
~~~ SolutionFragment {exname=ex3a-factorial-types}
val factorial: int -> int                     (* inferred by default *)
val factorial: int -> ML int                  (* same as above *)
val factorial: nat -> Tot int                 (* total function on nat inputs *)
val factorial: nat -> Tot nat                 (* stronger result type *)
val factorial: nat -> Tot (y:int{y>=1})       (* even stronger result type *)
~~~
~~
~

<!-- CH: This is causing too much unnecessary pain too early on
  The problem is that to give the following uncomparable type for factorial:
val factorial: x:int{x>=2} -> Tot (y:int{y>=2}) (* uncomparable to prev type *)
  One needs to unroll it as follows:
let rec factorial n =
  if n = 0 then 1
  else if n = 1 then 1
  else if n = 2 then 2
  else n * factorial (n - 1)

Rank the types
in order of increasing precision. Is it a total order?
~~ Answer
The types in the solution above are listed in increasing order of
precision, with the exception of the last two ones which are
uncomparable.  So no, subtyping is not a total order.
~~
-->

~ Exercise
フィボナッチ関数に対して型をいくつか与えてください。
~~ ExerciseFragment {exname=ex3b-fibonacci}
let rec fibonacci n =
  if n <= 1 then 1 else fibonacci (n - 1) + fibonacci (n - 2)
~~
~~ AnswerFragment {exname=ex3b-fibonacci}
[INCLUDE=code/solutions/ex3b-fibonacci.fst]
~~
~

## 補題

`factorial` 関数を書いて、型 `:(nat -> Tot nat)` を与えたとしましょう。
すると例えば `x > 2` ならば `factorial x > x` といったような、他の性質が気になるでしょう。
1つの方法は `factorial` の型を修正して、その型を F\* に再度証明させることです。
しかしこれは常に柔軟なわけではありません。
`x > 3` ならば `factorial x > 2 * x` も証明したいとしたらどうなるでしょうか:
`factorial` の型に対するこれらの性質による汚染は、明確に実用的ではありません。

けれども、`factorial` に関するさらなる性質を証明するために、`factorial` を定義して `:nat -> Tot nat` のような一般的な型を与えた後に、F\* では (補題と呼ばれる) 他の関数を書くことができます。

補題は、常に単純な `:unit` の値 `()` を返す _ゴースト_ 全域関数です。
計算上、補題それ自体は役立ちません---それらは作用を持たず、常に同じ値を返します。それならばポイントはなんでしょうか？
そのポイントは、補題によって返される値の型がプログラムに関する有用な性質を有していることにあります。

`factorial` に関する最初の補題として、それが正の数を常に返すことを証明してみましょう。

    val factorial_is_positive: x:nat -> GTot (u:unit{factorial x > 0})
    let rec factorial_is_positive x =
      match x with
      | 0 -> ()
      | _ -> factorial_is_positive (x - 1)

この補題のステートメントは `factorial_is_positive` に与えられた型です。
それは `x:nat` に対するゴースト全域関数で、リファインメント `factorial x > 0` と共にユニットを返します。
次の3行で `factorial_is_positive` を定義しており、`x` に対する帰納による証明を使ってこの補題を証明しています。
ここでの基本的なコンセプトは、全域関数を使ったプログラミングによって他の純粋な式に関する証明を書けることです。
この章の残りでこのような証明について詳細に議論します。

~ Remark
F\* では (計算上無意味な) ゴーストであるような式は1つの作用です。
`factorial_is_positive` の型における作用 `GTot` は、それがゴーストで全域関数であることを示しています。
~

### 依存関数型

~CH
Lemmas don't seem like the most intuitive way of introducing dependent
functions.  Can we find a more computationally relevant thing first?
See `max_ref_type` in `code/max.fst`?
~

この補題のステートメントをもう少しよく見てみましょう。

    val factorial_is_positive: x:nat -> GTot (u:unit{factorial x > 0})

これは F\* における *依存関数型* です。
なぜ *依存* するのでしょうか？
その結果の型はパラメータ `x:nat` の _値_ に依存しているのです。
例えば、`factorial_is_positive 0` は型 `:Tot (u:unit{factorial 0 > 0))` を持ちます。
これは `factorial_is_positive 1` の型と異なります。

依存関数を紹介したので、関数型の一般的な形を少し詳しく見てみましょう:

~ Center
`:x_1:t_1 -> ... -> x_n:t_n[x_1 ... x\(~n-1~\)] -> E t[x_1 ... x_n]`
~
関数の正規のパラメータそれぞれは `x\(~i~\)` と名付けられていて、それらの名前のスコープはそれに続く最初の矢印の右側です。
表記 `:t[x_1 ... x_m]` は `:t` 中に変数 `:x_1 ... x_m` が自由出現することを示しています。

### リファインメント型と補題に対するシンタックスシュガー

引数が2より大きいとき、`factorial` がその引数より厳密に大きいことをどうやって明記すべきでしょうか？
次は最初の試みです:

    val factorial_is_greater_than_arg_1: x:(y:nat{y > 2}) -> GTot (u:unit{factorial x > x})

これは上手く行きますが、2つの名前が必要になるため、関数の引数の型は少し不恰好です:
`y` はそのドメインを `2` より大きい自然数に制限するためで、`x` は返り値の型で引数に言及するためです。
このパターンはありふれていて、F\* はそのためのシンタックスシュガーを提供しています---`factorial` に与えた最初の型で既に見てきました。
それを使うことで、上記の型と等価で、より簡潔な次のような型を書くことができます。

    val factorial_is_greater_than_arg_2: x:nat{x > 2} -> GTot (u:unit{factorial x > x})

もう1つの疑いようのない不恰好な点は補題の返り値の型で、それは `:unit` 型のリファインメントを含んでいます。
これを簡潔にするために、F\* は `:Lemma` キーワードを提供していて、作用 `:GTot` の代わりに使うことができます。

例えば、`factorial_is_greater_than_arg_2` の型は (下記の) `factorial_is_greater_than_arg_3` の型と等価で、それは少し読み書きしやすいでしょう。

    val factorial_is_greater_than_arg_3: x:nat{x > 2} -> Lemma (factorial x > x)

また都合が良ければ、次のように書くこともできます:

    val factorial_is_greater_than_arg_4: x:nat -> Lemma (requires (x > 2))
                                                  (ensures (factorial x > x))

`requires` の後の式は関数/補題の _事前条件_ で、`ensures` の後の式はその _事後条件_ です。

### 帰納によって証明された単純な補題について詳細に

ここで `factorial_is_greater_than_arg` の証明を詳細に見てみましょう。
それは次のようになります:

    let rec factorial_is_greater_than_arg x =
      match x with
      | 3 -> ()
      | _ -> factorial_is_greater_than_arg (x - 1)

この証明は (`let rec` で示された) 再帰関数です;
この関数は `x` に対する場合分けで定義されています。

最初のケースは、引数が `3` で;
そのため `factorial 3 > 3` を証明する必要があります。
F\* はこの性質に相当する証明を生成し、前に提供された `factorial` の定義が与えられたとき、それを証明できるかどうかを確かめるよう [Z3] に要求します---Z3 は `factorial 3 = 6` であり、もちろん `6 > 3` で、このケースの証明は完了します。
これはこの帰納の基底ケースです。

ケースは順番に解釈されるため、2番目のケースに辿り着いた場合、最初のケースに当てはまらないことを知っています。
すなわち、2番目のケースでは `factorial_is_greater_than_arg` の型から `x:nat{x > 2}` を、前のケースに当てはまらなかったので `x <> 3` であることを知っています。
別の言い方をすると、2つ目のケースは帰納ステップで、`x > 3` のときの証明を扱います。

くだけた表現をすると、このケースの証明は、次で与えられる帰納法の仮定を使って行なわれます:
```
forall n, 2 < n < x ==> factorial n > n
```
and our goal is to prove `factorial x > x`. Or, equivalently, that
`x * factorial (x - 1) > x`, knowing that `factorial (x - 1) > x - 1`; or
that `x*x - x > x`---which is true for `x > 3`.
Let's see how this works formally in F\*.

When defining a total recursive function, the function being defined
(`factorial_is_greater_than_arg` in this case) is available for use in the body
of the definition, but only at a type that ensures that the recursive
call will terminate. In this case, the type of `factorial_is_greater_than_arg` in
the body of the definition is:

    n:nat{2 < n && n < x} -> Lemma (factorial n > n)

This is, of course, exactly our induction hypothesis. By calling
`factorial_is_greater_than_arg (x - 1)` in the second case, we, in effect, make
use of the induction hypothesis to prove that
`factorial (x - 1) > x - 1`, provided we can prove that
`2 < x - 1 && x - 1 < x`---we give this to Z3 to prove, which it can,
since in this case we know that `x > 3`. Finally, we have to prove the
goal `factorial x > x` from the `x > 3` and the property we obtained
from our use of the induction hypothesis: again, Z3 proves this easily.

~ Exercise
Prove the following property for the fibonacci function:
~~ ExerciseFragment {exname=ex3c-fibonacci}
[INCLUDE=code/exercises/ex3c-fibonacci.fst:FibonacciGreaterThanArg]
~~
~~ AnswerFragment {exname=ex3c-fibonacci}
[INCLUDE=code/solutions/ex3c-fibonacci.fst:FibonacciGreaterThanArgProof]
~~
~

<!--
~ Exercise
Try proving that if `x >= 3` then `factorial x >= 2*x`.
~

~ Exercise
Try proving that if `x >= 4` then `factorial x > x*x`.
~

~ Exercise
Try proving that if `x >= 6` then `factorial x > x*x*x`.
~
Without learning a lot more about F\*, it's unlikely that you will
succeed at that last exercise. Proving properties about non-linear
arithmetic is quite difficult and Z3, as most other theorem provers, are
not great at doing it unassisted.
-->

## Admit

When constructing proofs it is often useful to assume parts of proofs,
and focus on other parts. For instance, when doing case analysis we
often want to know which cases are trivial and are automatically solved
by F\*, and which ones need manual work. We can achieve this by admitting
all but one case, if F\* can prove the lemma automatically, then the case
is trivial. For this F\* provides an `admit` function, that can be used
as follows:
```
    let rec factorial_is_greater_than_arg x =
      match x with
      | 3 -> ()
      | _ -> admit()
```
Since type-checking this succeeds we know
that the base case of the induction is trivially proved and need
to focus our effort on the inductive case.

~CH
How about adding (proper) monotonicity?
```
val fact_monotone : n:nat -> m:nat -> Lemma (requires (n <= m))
                                            (ensures (factorial n <= factorial m))
                                            (decreases m)
let rec fact_monotone n m =
  match m - n with
  | 0 -> ()
  | _ -> fact_monotone n (m-1)
```
~


<!--
## Automatic induction { #auto-ind }

Many of these proofs by induction are quite boring. You simply do case
analysis and call the induction hypothesis as needed. Surely, we should
automate this for you---and we do, in many cases using an **experimental**
_automatic induction_ feature.

Here's another proof of `factorial_is_greater_than_arg`:

    let rec factorial_is_greater_than_arg n = by_induction_on n factorial_is_greater_than_arg

Calling `by_induction_on` with `n` and `factorial_is_greater_than_arg` as argument
causes F\* to encode the induction hypothesis as a quantified logical
formula and feed it to Z3, which in simple examples can take care of
the rest.
-->

## Under the hood: `:bool` versus `:Type` { #sec-bool-versus-type }

_You can probably skip this section on a first reading, if the title
sounds mysterious to you. However, as you start to use quantified
formulas in refinement types, you should make sure you understand this
section._

We mentioned earlier that a refinement type has the form `:x:t{phi(x)}`.
In its primitive form, `phi` is in fact a type, a predicate on the value
`x:t`. We allow you to use a boolean function in place of a type: under
the covers, we implicitly coerce the boolean to a type, by adding the
coercion

    b2t (b:bool) : Type = (b == true)

The type '`==`' is the type
constructor for the equality predicate; it is different from '`=`', which
is a boolean function comparing a pair of values. Additionally, '`==`' is
heterogeneous: you can speak about equality between any pair of values,
regardless of their type. In contrast, '`=`' is homogeneous.

The propositional connectives, `:/\`, `:\/`, and `:~`, for conjunction,
disjunction and negations are type constructors. We also include `:==>`
and `:<==>` for single and bidirectional implication. In contrast,
`:&&`, `:||`, and `:not` are boolean functions.

Often, because of the implicit conversion from `:bool` to `:Type`, you
can almost ignore the distinction between the two. However, when you
start to write refinement formulas with quantifiers, the distinction
between the two will become apparent.

Both the universal quantifier `forall`, and the existential quantifier
`exists`, are only available in `:Type`. When you mix refinements that
include boolean function and the quantifiers, you need to use the
propositional connectives. For example, the following formula
is well-formed:

    canRead e /\ forall x. canWrite x ==> canRead x

It is a shorthand for the following, more elaborate form:

    b2t(canRead e) /\ forall x. b2t(canWrite x) ==> b2t(canRead x)

On the other hand, the following formula is not well-formed; F\* will
reject it:

    canRead e && forall x. canWrite x ==> canRead x

The reason is that the quantifier is a type, whereas the `:&&` expects a
boolean. While a boolean can be coerced to a type, there is no coercion
in the other direction.


# Simple inductive types

~CH

We should explain all our syntactic restrictions on naming things:
Constructors have to start uppercase, types can be upper or lower
case, right? (although they are usually lower case), variables
have to start lower-case. In particular every lower case thing
in a pattern is interpreted as a variable, even if it's already
bound somewhere else. We might want to raise a warning in such
cases.
~

Here's the standard definition of (immutable) lists in F\*.

    type list 'a =
      | Nil  : list 'a
      | Cons : hd:'a -> tl:list 'a -> list 'a

We note some important conventions for the constructors of a data type in F\*.

+ Constructor names must begin with a capital letter.

+ When not writing effects in constructor types,
  the default effect on the result is `Tot`
  (as opposed to function types in general).
  So, when we write `Cons: 'a -> list 'a -> list 'a`,  F\* desugars it to
  `Cons: 'a -> Tot (list 'a -> Tot (list 'a))`.

+ Constructors can be curried. So, we usually define our inductive
  types as above so that we write `Cons hd tl` (curried)
  rather than `Cons(hd,tl)` (uncurried).

+ Constructors can be partially applied, so `Cons hd` is legal and has
  type `:list 'a -> Tot (list 'a)` when `hd:'a`.

<!-- XXX -->

The `list` type is defined in F\*'s standard prelude and is available
implicitly in all F\* programs. We provide special (but standard) syntax
for the list constructors:

* `[]` is `Nil`
* `[v1;...;vn]` is `Cons v1 ... (Cons vn Nil)`
* `hd::tl` is `Cons hd tl`.

You can always just write out the constructors like `Nil` and `Cons`
explicitly, if you find that useful (e.g., to partially apply `Cons`).

<!--
The prelude also defines the `option` type, shown below:

```
  type option (a:Type) =
      | None : option a
      | Some : v:a -> option a
```
-->

## Proofs about basic functions on lists { #sec-basic-lists }

The usual functions on lists are programmed in F\* just as in any other ML dialect.
Here is the `length` function:

    val length: list 'a -> Tot nat
    let rec length l = match l with
      | [] -> 0
      | _ :: tl -> 1 + length tl

The type of `length` proves it is a total function on lists of `:'a`-typed
values, returning a non-negative integer.

<!--
~Remark
Like in ML, you could have written the type of `length` as
`:list 'a -> Tot nat`. The 'ticked'-variable `:'a` is implicitly a type
variable that is bound at the top-level of the enclosing function type
~
~CH
Don't understand this comment. That's exactly what you already
 wrote. Do you actually mean to say that this could also have been written as
 `a:Type -> list a -> Tot nat`?
~
~BB
I don't understand either, it is certainly wrong
~
-->


~ Exercise
Here's the `append` function that concatenates two lists.
~~ ExerciseFragment {exname=ex4a-append-intrinsic}
let rec append l1 l2 = match l1 with
  | [] -> l2
  | hd :: tl -> hd :: append tl l2
~~
Give `append` a type that proves it always returns a list
whose length is the sum of the lengths of its arguments.

~~ AnswerFragment {exname=ex4a-append-intrinsic}
    l1:list 'a -> l2:list 'a -> Tot (l:list 'a{length l = length l1 + length l2})
~~
~

~ Exercise
Give `append` the weak type below,
then prove the same property as in the previous exercise using a lemma.
~~ ExerciseFragment {exname=ex4b-append-extrinsic}
val append:list 'a -> list 'a -> Tot (list 'a)
~~
~~ AnswerFragment {exname=ex4b-append-extrinsic}
val append_len: l1:list 'a -> l2:list 'a
             -> Lemma (requires True)
                      (ensures (length (append l1 l2) = length l1 + length l2)))
let rec append_len l1 l2 = match l1 with
    | [] -> ()
    | hd::tl -> append_len tl l2
~~
~

~ Exercise
Define a function `mem: x:'a -> l:list 'a -> Tot bool` that
decides whether `x` is present in the `l` or not, then prove it satisfies the
following property:
~~ ExerciseFragment {exname=ex4c-mem}
val append_mem:  l1:list 'a -> l2:list 'a -> a:'a
        -> Lemma (ensures (mem a (append l1 l2)  <==>  mem a l1 || mem a l2))
~~
~~ AnswerFragment {exname=ex4c-mem}

val mem: 'a -> list 'a -> Tot bool
let rec mem a l = match l with
  | [] -> false
  | hd::tl -> hd=a || mem a tl

val append_mem:  l1:list 'a -> l2:list 'a -> a:'a
    -> Lemma (ensures (mem a (append l1 l2)  <==>  mem a l1 || mem a l2))
let rec append_mem l1 l2 a = match l1 with
  | [] -> ()
  | hd::tl -> append_mem tl l2 a
~~
~


## To type intrinsically, or to prove lemmas?

As the previous exercises illustrate, you can prove properties either
by enriching the type of a function or by writing a separate lemma
about it---we call these the 'intrinsic' and 'extrinsic' styles,
respectively. Which style to prefer is a matter of taste and
convenience: generally useful properties are often good candidates for
intrinsic specification (e.g, that `length` returns a `nat`); more
specific properties are better stated and proven as lemmas. However,
in some cases, as in the following example, it may be impossible to
prove a property of a function directly in its type---you must resort
to a lemma.

    val reverse: list 'a -> Tot (list 'a)
    let rec reverse = function
      | [] -> []
      | hd::tl -> append (reverse tl) [hd]

Let's try proving that reversing a list twice is the identity function.
It's possible to
*specify* this property in the type of `reverse` using a refinement type.

    val reverse: f:(list 'a -> Tot (list 'a)){forall l. l = f (f l)}

~CH
This signature doesn't work:
append.fst(21,0-27,0) : Error
Expected a term of type "f:(_:(list 'a) -> Tot (list 'a)){(forall (l:(list 'a)). ((l = (f (f l))) == true))}";
got a function "(fun _682:<UNKNOWN> -> (match _682 with (Nil )  -> Nil
	(Cons hd tl)  -> (append (reverse tl) (Cons hd Nil))))" (More arguments than annotated type (Typ_refine))
~

However, F\* refuses to accept this as a valid type for `reverse`:
proving this property requires two separate inductions, neither of
which F\* can perform automatically.

Instead, one can use two lemmas to prove the property we care about. Here
it is:

    let snoc l h = append l [h]

    val snoc_cons: l:list 'a -> h:'a -> Lemma (reverse (snoc l h) = h::reverse l)
    let rec snoc_cons l h = match l with
      | [] -> ()
      | hd::tl -> snoc_cons tl h

    val rev_involutive: l:list 'a -> Lemma (reverse (reverse l) = l)
    let rec rev_involutive l = match l with
      | [] -> ()
      | hd::tl -> rev_involutive tl; snoc_cons (reverse tl) hd

In the `Cons` case of `rev_involutive` we are explicitly applying not just
the induction hypothesis but also the `snoc_cons` lemma we proved above.

~Exercise
Prove that reverse is injective, i.e.,
~~ ExerciseFragment {exname=ex4d-reverse}
[INCLUDE=code/exercises/ex4d-reverse.fst:RevInjective]
~~
~~ Answer
Perhaps you did it like this:
~~~ SolutionFragment {exname=ex4d-reverse}
[INCLUDE=code/solutions/ex4d-reverse.fst:RevInjective1]
~~~
That's quite a tedious proof, isn't it. Here's a simpler proof.
~~~ SolutionFragment {exname=ex4d-reverse}
[INCLUDE=code/solutions/ex4d-reverse.fst:RevInjective2]
~~~
The `rev_injective_2` proof is based on the idea that every involutive
function is injective. We've already proven that `reverse` is
involutive. So, we invoke our lemma, once for `l1` and once for `l2`.
This gives to the SMT solver the information that `reverse (reverse
l1) = l1` and `reverse (reverse l2) = l2`, which suffices to complete
the proof. As usual, when structuring proofs, lemmas are your friends!
~~
~

## Higher-order functions on lists

### Mapping

We can write higher-order functions on lists,
i.e., functions taking other functions as arguments.
Here is the familiar `map`:

      let rec map f l = match l with
        | [] -> []
        | hd::tl -> f hd :: map f tl

It takes a function `f` and a list `l` and it applies `f` to each element in `l`
producing a new list. More precisely `map f [a1; ...; a_n]` produces the list
`[f a1; ...; f a_n]`. For example:

    map (fun x -> x + 1) [0;1;2] = [1;2;3]

As usual, without any specification, F\* will infer for `map` type
`:('a -> 'b) -> list 'a -> list 'b`. Written explicitly, the type of
`map` is `:('a -> ML 'b) -> Tot (list 'a -> ML (list 'b))`.  Notice
that the type of `f` also defaults to a function with `:ML` effect.

By adding a type annotation we can give a _different_ type to `map`:

    val map: ('a -> Tot 'b) -> list 'a -> Tot (list 'b)

This type is neither a subtype nor a supertype of the type F\*
inferred on its own.

>**No parametric polymorphism on effects**: You might hope to give
`map` a very general type, one that accepts a function with any effect
`E` and returns a function with that same effect. This would require a
kind of effect polymorphism, which *F\* does not support*. This may
lead to some code duplication. We plan to address this by allowing you
to write more than one type for a value, an ad hoc overloading
mechanism.


### Finding

~ Exercise

We define a `find` function that given a boolean function `f` and a list
`l` returns the first element in `l` for which `f` holds. If no element
is found `find` returns `None`; for this we use the usual `:option` type (shown
below and available in F\*'s standard prelude).

~~ ExerciseFragment {exname=ex4e-find}
    type option 'a =
       | None : option 'a
       | Some : 'a -> option 'a

    let rec find f l = match l with
      | [] -> None
      | hd::tl -> if f hd then Some hd else find f tl
~~

Prove that if `find` returns `Some x` then `f x = true`.
Is it better to do this intrinsically or extrinsically? Do it both ways.

~~ AnswerFragment {exname=ex4e-find}
[INCLUDE=code/solutions/ex4e-find.fst]
~~
~

~Exercise
Define the `fold_left` function on lists, so that

    fold_left f [b1; ...; bn] a = f (bn, ... (f b2 (f b1 a)))

Prove that `(fold_left Cons l [] = reverse l)`.
(The proof is a level harder from what we've done so far)
~~ ExerciseFragment {exname=ex4f-fold-left}
val fold_left_cons_is_reverse: l:list 'a -> l':list 'a ->
      Lemma (fold_left Cons l l' = append (reverse l) l')
~~
~~ AnswerFragment {exname=ex4f-fold-left}
[INCLUDE=code/solutions/ex4f-fold-left.fst:FoldLeftInteresting]
~~
~

<!-- too many similar exercises
~Exercise
Define the `fold_right` function on lists, so that
`fold_right f [a1; ...; an] b` computes `f a1 (f a2 (... (f an b) ...))`.
Prove that `(fold_right Cons [] l = l)`.
~
-->

## Implicitly defined functions on inductive types

For each definition of an inductive type, F\* automatically introduces a
number of utility functions: for each constructor, we have a
*discriminator*; and for each argument of each constructor, we have a
*projector*. We describe these next, using the list type (repeated below)
as a running example.

    type list 'a =
      | Nil  : list 'a
      | Cons : hd:'a -> tl:list 'a -> list 'a

### Discriminators

A discriminator is a boolean-valued total function that tests whether a
term is the application of a particular constructor. For the `list` type,
we have two discriminators:

    val is_Nil: list 'a -> Tot bool
    let is_Nil xs = match xs with [] -> true | _ -> false

    val is_Cons: list 'a -> Tot bool
    let is_Cons xs = match xs with _::_-> true | _ -> false

### Projectors

From the type of the `Cons` constructor, F\* generates the following
signatures:

    val Cons.hd : l:list 'a{is_Cons l} -> Tot 'a
    val Cons.tl : l:list 'a{is_Cons l} -> Tot (list 'a)

(here `Cons.hd` is a qualified name)

This indicates why the names `hd` and `tl` in the types of `Cons` are
significant: they correspond to the names of the auto-generated
projectors. If you don't name the arguments of a data constructor, F\*
will generate names automatically (although these names are derived from
the position of the arguments and their form is unspecified; so, it's
good practice to name the arguments yourself).

<!--
~ Remark
F\* also generates projectors corresponding to the type arguments of each
constructor. We show them below for completeness, although you may have
trouble understanding what these signatures mean until you've read a bit
more about higher kinds in Section [#sec-indexed-types]. Besides, for the
list type, these type projectors are not particularly useful.

    type Nil.a : a:Type -> l:list a{is_Nil l} -> Type
    type Cons.a : a:Type -> l:list a{is_Cons l} -> Type

The projectors for more complex inductive types have more complex
signatures---we will see this in the section on indexed types
([#sec-indexed-types]).
~
-->

~Exercise
Write functions (call them `hd` and `tl`) whose types match
those of `Cons.hd` and `Cons.tl`.
~~ ExerciseFragment {exname=ex4g-hd-tl}
[INCLUDE=code/exercises/ex4g-hd-tl.fst]
~~
~~Answer
~~~ SolutionFragment {exname=ex4g-hd-tl}
val hd : l:list 'a{is_Cons l} -> Tot 'a
let hd l =
  match l with
  | h :: t -> h

val tl : l:list 'a{is_Cons l} -> Tot (list 'a)
let tl l =
  match l with
  | h :: t -> t
~~~
~~
~

~CH
The Next exercise seems easy, why does it come up so late?
Anyway, it's too late to switch later now, we can do such things
when we have an automatic way ;)
~

~Exercise
Write a function that returns the `n`th element of a list. Give a
type that ensures it is total.
~~ ExerciseFragment {exname=ex4h-nth}
(* Write your code here *)
~~
~~ AnswerFragment {exname=ex4h-nth}
val nth : l:list 'a -> n:nat{n < length l} -> 'a
let rec nth l n =
  match l with
  | h :: t -> if n = 0 then h else nth t (n-1)
~~
~

<!--
## Exhaustiveness of pattern matching

Whenever you pattern match a term (to analyze it by cases), F\* insists
on proving that you have handled all the cases. We call this the
`exhaustiveness check`, and unlike in F\# or OCaml, it is implemented
semantically.
-->

## Tuples and records

F\* provides syntactic sugar for tuples. Under the covers, tuples are
just inductive types: tuples of size 2--8 are defined in the standard
prelude. (You can add to this, if you like.) Here's the definition of
pairs from the prelude:

    type tuple2 'a 'b =
      | MkTuple2: _1:'a -> _2:'b -> tuple2 'a 'b

You can write `(5, 7)` instead of `MkTuple2 5 7`, and give it the type
`(int * int)` as a shorthand for `tuple2 int int`.

This notation generalizes to tuples of arbitrary size, so long as the
corresponding `tupleN` data type is defined in the prelude.

F\* also provides syntax for records, although internally records (like
tuples) boil down to data types with a single constructor. Here's an
example:


    type triple 'a 'b 'c = {fst:'a; snd:'b; third:'c}
    let f x = x.fst + x.snd + x.third

F\* accepts this program, giving `f` the type `:(triple int int int -> Tot int)`.

This is equivalent to the following, more verbose, source program:


    type triple 'a 'b 'c =
      | MkTriple: fst:'a -> snd:'b -> third:'c -> triple 'a 'b 'c

    let f x = MkTriple.fst x + MkTriple.snd x + MkTriple.third x

# Proving termination { #sec-termination }

In F\* every pure function is proved to terminate. The termination
check used by F\* is based on a semantic criterion, not syntactic
conditions. We quickly sketch the basic structure of the F\*
termination check---you'll need to understand a bit of this in order
to write more interesting programs.

## A well-founded partial order on values

In order to prove a function terminating in F\* one provides a
measure: a pure expression depending on the function's arguments. F\*
checks that this measure strictly decreases on each recursive call.
The measure for the arguments of the call is compared to the measure
for the previous call according to a well-founded partial order on F\*
values. We write `v1 << v2` when `v1` _precedes_ `v2` in this order.

> A relation `R` is a well-founded partial order on a set `S` if, and
> only if, `R` is a partial order on `S` and there are no infinite
> descending chains in `S` related by `R`. For example, taking `S` to
> be `nat`, the set of natural numbers, the integer ordering `<` is a
> well-founded partial order (in fact, it is a total order).

Since the measure strictly decreases on each recursive call, and there
are no infinite descending chains, this guarantees that the function
eventually stops making recursive calls, i.e., it terminates.

### The precedes relation

1. **The ordering on integers**: Given `i, j : nat`,
   we have `i << j <==> i < j`.

   _Note_: Negative integers are not related by the `<<` relation,
   which is only a _partial_ order.

2. **The subterm ordering on inductive types**: For any value
    `D v1 ... vn` of an inductive type (where `D` is a constructor applied
    to arguments `v1` to `vn`) we include `v_i << v`, for all `i`.
    That is, the sub-terms of a well-typed constructed term
    precede the constructed term. (The exception to this rule is `lex_t` below).
~CH
I guess there is also an exception for types with negative occurrences, right?
~

3. **The lexicographic ordering on lex_t**, as described below.


### Lexically ordered pairs

Take a look at the classic function, `ackermann`:

    val ackermann: m:nat -> n:nat -> Tot nat
    let rec ackermann m n =
      if m=0 then n + 1
      else if n = 0 then ackermann (m - 1) 1
      else ackermann (m - 1) (ackermann m (n - 1))

Why does it terminate? At each recursive call, it is *not* the case that
all the arguments are strictly less than the arguments at the previous
call, e.g, in the second branch, `n` increases from `0` to `1`. However,
this function does in fact terminate, and F\* proves that it does.

The reason is that although each argument does not decrease in every
recursive call, when taken together, the ordered pair of arguments `(m,n)`
does decrease according to a *lexical ordering* on pairs.

In its standard prelude, F\* defines the following inductive type:

    type lex_t =
      | LexTop  : lex_t
      | LexCons : #a:Type -> a -> lex_t -> lex_t

(The `#` sign marks the first argument as implicit, see [#sec-implicit-arguments].)

**The lexicographic ordering on `lex_t`** is the following:

* `LexCons v1 v2 << LexCons v1' v2'`, if and only if, either
  `v1 << v1'`; or `v1=v1'` and `v2 << v2'`.

* If `v:lex_t` and `v <> LexTop`, then `v << LexTop`.

~MK
We could explain what that means, that longer `lex_t` are smaller?
~

**We include the following syntactic sugar**:

>`%[v1;...;v_n]` is shorthand for `(LexCons v_1 ... (LexCons v_n LexTop))`

## A termination proof in detail

Suppose we are defining a function by recursion, using the following form:


    val f: y1:t_1 -> .. -> yn:t_n -> Tot t
    let rec f x1 .. xn = e

Usually, in ML, when type-checking `e`, the recursively bound function
`f` is available for use in `e` at the type
`y1:t_1 -> .. -> yn:t_n -> Tot t`, exactly the type written by the
programmer. This type is, however, not sufficient to guarantee that an
invocation of `f` does not trigger an infinite chain of recursive calls.

To prove termination (i.e., to rule out infinitely deep recursive calls), F\*
uses a different rule for type-checking recursive functions. The recursively bound name `f`
is available for use in `e`, but only at the more restrictive type shown below:

       y1:t1
    -> ...
    -> yn:t_n{%[y_1;...;y_n] << %[x_1;...;x_n]}
    -> Tot t

That is, by default, F\* requires the function's parameters to decrease
according to the lexical ordering of the parameters (in the order in
which they appear, excluding all function-typed parameters). (There is a
way to override this default---see Section [#sec-decreases-clause].)

Let's see how this works on a couple of examples.

### Ackermann

F* can show automatically that the `ackermann` function

    1.  let rec ackermann m n =
    2.    if m=0 then n + 1
    3.    else if n = 0 then ackermann (m - 1) 1
    4.    else ackermann (m - 1)
    5.                   (ackermann m (n - 1))

is terminating and has type:

    ackermann : nat -> nat -> Tot nat

F* gives this function a default termination metric, so this expands out to:

    ackermann : m:nat -> n:nat -> Tot nat (decreases %[m;n])

The `decreases` clause will be discussed in the next section. In this
example it leads to the F\* type-checker using the following more
restrictive type for the recursive calls in the body of `ackermann`:

    ackermann: m':nat
            -> n':nat{%[m';n'] << %[m;n]}
            -> Tot nat

At each of three recursive calls to `ackermann`, we need to prove, not
only that the arguments are non-negative, but that they precede the
previous arguments according to the refinement formula above.


* For the call at line 3, we have to show that `%[(m - 1);1] << %[m;n]`.
This works out, since `m - 1 << m` according to the integer ordering, and
we can disregard the rest of the terms.

* The call at line 4 verifies for the same reason---the first argument
decreases.

* For the call at line 5, we have to show that `%[m; (n-1)] << %[m; n]`.
Here, the first elements of each pair are equal, so we look at the second
element, and there `n - 1 << n`, and we're done.

### Decreases clauses {#sec-decreases-clause}

Of course, sometimes you will need to override the default measure for
recursive functions. If we just swap the arguments of the `ackermann`
function the default measure no longer works and we need to add a
`decreases` clause explicitly choosing a lexicographic ordering that
first compares `m` and then `n`:

    val ackermann_swap: n:nat -> m:nat -> Tot nat (decreases %[m;n])
    let rec ackermann_swap n m =
       if m=0 then n + 1
       else if n = 0 then ackermann_swap 1 (m - 1)
       else ackermann_swap (ackermann_swap (n - 1) m)
                           (m - 1)

The optional `decreases` clause is a second argument to the `Tot` effect.
It is, in general, a total expression over the arguments of the function.

<!-- this is messed up because of mult_assoc
~Exercise
Program a tail-recursive version of `factorial` and prove it
total. Also, prove that it is functionally equivalent to `factorial`.

~~Answer
    val fact: a:nat -> n:nat -> Tot nat (decreases n)
    let rec fact a n =
      if n = 0 then a
      else fact (a * n) (n - 1)

    val fact_is_ok: a:nat
                 -> n:nat
                 -> Lemma (ensures (fact a n = a * factorial n))
                          (decreases n)
    let rec fact_is_ok a = function
      | 0 -> ()
      | n -> fact_is_ok (a * n) (n - 1)
~~
~
-->

~Exercise
Here is a more efficient (tail-recursive) variant of the list
reverse function.
~~ ExerciseFragment {exname=ex5a-rev}
val rev : l1:list 'a -> l2:list 'a -> Tot (list 'a) (decreases l2)
let rec rev l1 l2 =
  match l2 with
  | []     -> l1
  | hd::tl -> rev (hd::l1) tl
~~
Prove the following lemma showing the correctness of this
efficient implementation with respect to the previous simple
implementation:
~~ ExerciseFragment {exname=ex5a-rev}
val rev_is_ok : l:list 'a -> Lemma (rev [] l = reverse l)
~~
~~ AnswerFragment {exname=ex5a-rev}
val append_assoc : xs:list 'a -> ys:list 'a -> zs:list 'a -> Lemma
      (ensures (append (append xs ys) zs = append xs (append ys zs)))
let rec append_assoc xs ys zs =
  match xs with
  | [] -> ()
  | x::xs' -> append_assoc xs' ys zs

val rev_is_ok_aux : l1:list 'a -> l2:list 'a -> Lemma
      (ensures (rev l1 l2 = append (reverse l2) l1)) (decreases l2)
let rec rev_is_ok_aux l1 l2 =
  match l2 with
  | [] -> ()
  | hd::tl  -> rev_is_ok_aux (hd::l1) tl; append_assoc (reverse tl) [hd] l1

val append_nil : xs:list 'a -> Lemma
      (ensures (append xs [] = xs))
let rec append_nil xs =
  match xs with
  | [] -> ()
  | _::tl  -> append_nil tl

val rev_is_ok : l:list 'a -> Lemma (rev [] l = reverse l)
let rev_is_ok l = rev_is_ok_aux [] l; append_nil (reverse l)
~~
~

~Exercise
(**Challenge!**) Here is a more efficient (tail-recursive)
variant of the Fibonacci function.
~~ ExerciseFragment {exname=ex5b-fib}
val fib : nat -> nat -> n:nat -> Tot nat (decreases n)
let rec fib a b n =
  match n with
  | 0 -> a
  | _ -> fib b (a+b) (n-1)
~~
Prove the following lemma showing the correctness of this
efficient implementation with respect to the previous simple
implementation:
~~ ExerciseFragment {exname=ex5b-fib}
val fib_is_ok : n:nat -> Lemma (fib 1 1 n = fibonacci n)
~~
~~ AnswerFragment {exname=ex5b-fib}
val fib_is_ok_aux : i:nat -> n:nat{i<=n} ->
      Tot (u:unit{fib (fibonacci i) (fibonacci (i+1)) (n-i) = fibonacci n})
      (decreases (n-i))
let rec fib_is_ok_aux i n =
  if i=n then ()
  else fib_is_ok_aux (i+1) n

val fib_is_ok : n:nat -> Lemma (fib 1 1 n = fibonacci n)
let fib_is_ok n = fib_is_ok_aux 0 n
~~
~

## Mutually recursive functions

The same strategy for proving termination also works for mutually
recursive functions. In the case of mutually recursive functions, the
F\* termination checker requires that all directly or mutually
recursive calls decrease the termination metric of the called
function. This is a quite strong requirement. Consider for instance
the following example:

```
val foo : l:list int -> Tot int
val bar : l:list int -> Tot int
let rec foo l = match l with
    | [] -> 0
    | x::xs -> bar xs
and bar l = foo l
```

This function is terminating because `foo` is always called (via
`bar`) on a sub-list. The call from `bar` to `foo` is not on a smaller
list though, and with the default metrics this example is rejected.

We can use a custom metric to convince F\* that the two functions are
terminating:

```
val foo : l:list int -> Tot int (decreases %[l;0])
val bar : l:list int -> Tot int (decreases %[l;1])
```

The metrics of `foo` and `bar` are both lexicographic tuples with the
argument `l` in the first position and `0` or `1` in the second. The
call from `foo` to `bar` decreases `l`, while the call from `bar` to
`foo` keeps `l` the same, but decreases the second component from `1`
to `0`.


# Putting the pieces together

We now look at two complete programs that exercise the various
features we have learned about so far. In each case, there are some
exercises to modify or generalize the programs.

## Quicksort on lists

A canonical example for program verification is proving various
sorting algorithms correct.

We'll start with lists of integers and describe some properties that
we'd like to hold true of a sorting algorithm, starting with a
function `sorted`, which decides when a list of integers is sorted in
increasing order.

```
  val sorted: list int -> Tot bool
  let rec sorted l = match l with
      | [] -> true
      | [x] -> true
      | x::y::xs -> x <= y && sorted (y::xs)
```

Given a sorting algorithm `sort`, we would like to prove the following
property, where `mem` is the list membership function from the earlier
exercise on lists (Section [#sec-basic-lists]).

    sorted (sort l) /\ ( forall i. mem i l <==> mem i (sort l) )

We will see below that this specification can still be improved.

### Implementing Quicksort

Here's a simple implementation of the quicksort algorithm. It always
picks the first element of the list as the pivot; partitions the rest
of the list into those elements greater than or equal to the
pivot, and the rest; recursive sorts the partitions; and slots the
pivot in the middle before returning.

    let rec sort l = match l with
      | [] -> []
      | pivot::tl ->
        let hi, lo  = partition (fun x -> pivot <= x) tl in
        append (sort lo) (pivot::sort hi)


~Exercise
Write the partition function and prove it total.
~~ExerciseFragment {exname=ex6a-partition}
val partition: ('a -> Tot bool) -> list 'a -> Tot (list 'a * list 'a)
~~
~~Answer

The following definition is included in F\*'s list library.
~~~ SolutionFragment {exname=ex6a-partition}
[INCLUDE=code/solutions/ex6a-partition.fst:Partition]
~~~

<!-- ~~~ SolutionFragment {exname=ex6a-partition} -->
<!-- val partition: ('a -> Tot bool) -> list 'a -> Tot (list 'a * list 'a) -->
<!-- let rec partition f = function  -->
<!--   | [] -> [], [] -->
<!--   | hd::tl ->  -->
<!--     let l1, l2 = partition f tl in -->
<!--     if f hd  -->
<!--     then hd::l1, l2 -->
<!--     else l1, hd::l2 -->
<!-- ~~~ -->
~~
~

### Specifying `sort`


We'll verify `sort` intrinsically, although we'll have to use some
additional lemmas. Here's a first-cut at a specification. Try asking
F\* to prove it.

    val sort_0: l:list int -> Tot (m:list int{sorted m /\ (forall i. mem i l <==> mem i m) })

~CH
Is this an exercise or not? :)
~

Unsurprisingly, it fails, on several counts:

1. We fail to prove the function total. On what grounds can we claim
   that each recursive call to `sort` is on a smaller argument?
   Intuitively, at each recursive call, the length of the list passed
   as an argument is strictly smaller, since it is a partition of
   `tl`. To express this, we'll need to add a decreases clause.


2. We fail to prove both the sortedness property and the membership
   property---we need some lemmas about `partition` and also about the
   `sorted` function.

Let's try again:

    val sort: l:list int -> Tot (m:list int{sorted m
                                         /\ forall i. mem i l <==> mem i m})
                                (decreases (length l))

And here are a couple of lemmas about `partition` and `sorted`:


     val partition_lemma: f:('a -> Tot bool)
        -> l:list 'a
        -> Lemma (requires True)
                 (ensures ((length (fst (partition f l))
                          + length (snd (partition f l)) = length l
                      /\ (forall x. mem x (fst (partition f l)) ==> f x)
                      /\ (forall x. mem x (snd (partition f l)) ==> not (f x))
                      /\ (forall x. mem x l = (mem x (fst (partition f l))
                                            || mem x (snd (partition f l)))))))
     let rec partition_lemma f l = match l with
       | [] -> ()
       | hd::tl -> partition_lemma f tl

~Remark
The repeated sub-terms like `fst (partition f l)` in specifications
call for a `let`-binding construct in types. We will see how
to do that in a later section---once we have introduced some additional
machinery.
~

     val sorted_concat_lemma: l1:list int{sorted l1}
                           -> l2:list int{sorted l2}
                           -> pivot:int
                           -> Lemma (requires ((forall y. mem y l1 ==> not (pivot <= y))
                                            /\ (forall y. mem y l2 ==> pivot <= y)))
                                    (ensures (sorted (append l1 (pivot::l2))))
     let rec sorted_concat_lemma l1 l2 pivot = match l1 with
      | [] -> ()
      | hd::tl -> sorted_concat_lemma tl l2 pivot

Finally, we also need a universally quantified variant of the
`append_mem` lemma presented in a previous exercise:

     val append_mem:  l1:list 'a
                   -> l2:list 'a
                   -> Lemma (requires True)
                            (ensures (forall a. mem a (append l1 l2) = (mem a l1 || mem a l2)))
     let rec append_mem l1 l2 = match l1 with
       | [] -> ()
       | hd::tl -> append_mem tl l2


Armed with these lemmas, let's return to our implementation of
quicksort. Unfortunately, with the lemmas as they are, we still can't
prove our original implementation of quicksort correct. As we saw with
our proofs of `rev_injective` (Section [#sec-basic-lists]), we need to
explicitly invoke our lemmas in order to use their properties. We'll
be able to do better in a minute, but lets see how to modify `sort` by
calling the lemmas to make the proof go through.

    let cmp i j = i <= j
    val sort_tweaked: l:list int -> Tot (m:list int{sorted m /\ (forall i. mem i l = mem i m)})
                                        (decreases (length l))
    let rec sort_tweaked l = match l with
      | [] -> []
      | pivot::tl ->
        let hi', lo' = partition (cmp pivot) tl in
        partition_lemma (cmp pivot) tl;
        let hi = sort_tweaked hi' in
        let lo = sort_tweaked lo' in
        append_mem lo (pivot::hi);
        sorted_concat_lemma lo hi pivot;
        append lo (pivot::hi)

That works, but it's pretty ugly. Not only did we have to pollute our
implementation with calls to the lemmas, in order to make those calls,
we had to further rewrite our code so that we could bind names for
the arguments to those lemmas. We can do much better.


### SMT Lemmas: Bridging the gap between intrinsic and extrinsic proofs

If only we had given `partition` and `sorted` richer intrinsic types,
types that captured the properties that we proved using lemmas, we
wouldn't have had to pollute out implementation of quicksort. This is
a significant advantage of using the intrinsic proof style---every
call of a function like `partition (fun x -> pivot <= x) tl`
immediately carries all the properties that were proven intrinsically
about the function.

However, polluting the type of a general-purpose function with a very
application-specific type would also be awful. Consider enriching the
type of `sorted` with the property proven by
`sorted_concat_lemma`. The lemma is highly specialized for the
quicksort algorithm, whereas `sorted` is a nice, general specification
of sortedness that would work for insertion sort or merge sort, just
as well. Polluting its type is a non-starter. So, it seems we are
caught in a bind.

Wouldn't it be nice if there were some way to retroactively associate
a property proven about a function `f` by a lemma directly with `f`,
so that every application `f x` immediately carries the lemma
properties? F\* provides exactly such a mechanism, which provides a
way to bridge the gap between extrinsic and intrinsic proofs.

Let's say we wrote the type of `partition_lemma` as below---the only
difference is in the very last line, the addition of `[SMTPat
(partition f l)]`. That line instructs F\* and the SMT solver to
associate with every occurrence of the term `partition f l` the
property proven by the lemma.

    val partition_lemma: f:('a -> Tot bool)
      -> l:list 'a
      -> Lemma (requires True)
               (ensures ((length (fst (partition f l))
                        + length (snd (partition f l)) = length l
                    /\ (forall x. mem x (fst (partition f l)) ==> f x)
                    /\ (forall x. mem x (snd (partition f l)) ==> not (f x))
                    /\ (forall x. mem x l = (mem x (fst (partition f l))
                                          || mem x (snd (partition f l)))))))
                         [SMTPat (partition f l)]

Likewise, here's a revised type for `sorted_concat_lemma`. This time,
we instruct F\* and the SMT solver to associate the lemma property
only with very specific terms: just those that have the shape
```
sorted (append 11 (pivot::l2))
```
The more specific a pattern you can provide,
the more discriminating the SMT solver will be in applying lemmas,
keeping your verification times acceptable.

    val sorted_concat_lemma: l1:list int{sorted l1}
                          -> l2:list int{sorted l2}
                          -> pivot:int
                          -> Lemma (requires ((forall y. mem y l1 ==> not (pivot <= y))
                                           /\ (forall y. mem y l2 ==> pivot <= y)))
                                   (ensures (sorted (append l1 (pivot::l2))))
                             [SMTPat (sorted (append l1 (pivot::l2)))]

Finally, we also revise the type for `append_mem` in the same way:

    val append_mem:  l1:list 'a
                  -> l2:list 'a
                  -> Lemma (requires True)
                           (ensures (forall a. mem a (append l1 l2) = (mem a l1 || mem a l2)))
                           [SMTPat (append l1 l2)]
    let rec append_mem l1 l2 = match l1 with
      | [] -> ()
      | hd::tl -> append_mem tl l2


~Remark
 Use `SMTPat` with care! If you specify a bad pattern, you will get
 very unpredictable performance from the verification engine. To
 understand the details behind `SMTPat`, you should read up a bit on
 patterns (aka triggers) for quantifiers in SMT solvers.

~

With these revised signatures, we can write `sort` just as we
originally did, and give it the type we want. The SMT solver implicitly
derives the properties it needs from the lemmas that we have provided.

    let cmp i j = i <= j
    val sort: l:list int -> Tot (m:list int{sorted m /\ (forall i. mem i l = mem i m)})
                                (decreases (length l))
    let rec sort l = match l with
      | [] -> []
      | pivot::tl ->
        let hi, lo = partition (cmp pivot) tl in
        append (sort lo) (pivot::sort hi)


### Exercises

~CH
New solution files don't yet compile.
~

~CK
Now solved.
~

~CH
Exercise files still missing.
~

~CK
I do not write an exercise file Exercises 6c and 6d since it is exactly
the same as for Exercide 6b, and would thus duplicate code.
~

~Exercise
Starting from this implementation (given below), generalize `sort` so
that it works on lists with an arbitrary element type, instead of just
lists of integers. Prove it correct.
~~ ExerciseFragment {exname=ex6b-sort-poly}
(* Start from the code in the "Load in editor" link *)
~~

~~ AnswerFragment {exname=ex6b-sort-poly}
[INCLUDE=code/solutions/ex6b-sort-poly.fst]
~~
~

~Exercise {exname=ex6c-break-sort-spec}
Our specification for `sort` is incomplete. Why? Can you write a
variation of `sort` that has the same specification as the one above,
but discards some elements of the list?
~~ ExerciseFragment {exname=ex6b-sort-poly}
(* Start from the code in the "Load in editor" link *)
~~

~~ Answer
The specification does not ensure that the resulting list is a
permutation of the initial list: it could discard or repeat some
elements.
~~~ SolutionFragment {exname=ex6c-break-sort-spec}
[INCLUDE=code/solutions/ex6c-break-sort-spec.fst]
~~~
~~
~

~ Exercise
Fix the specification to ensure that `sort` cannot discard any
elements in the list. Prove that `sort` meets the specification.
~~ ExerciseFragment {exname=ex6b-sort-poly}
(* Start from either the problem or the solution of exercise 6b *)
~~
~~ AnswerFragment {exname=ex6d-no-discard}
[INCLUDE=code/solutions/ex6d-no-discard.fst]
~~
~

~ Exercise
Implement insertion sort and prove the same properties.
~~ ExerciseFragment {exname=ex6e-insertion-sort}
val sort : l:list int -> Tot (m:list int{sorted m /\ (forall x. mem x l == mem x m)})
~~
~~ AnswerFragment {exname=ex6e-insertion-sort}
[INCLUDE=code/solutions/ex6e-insertion-sort.fst]
~~
~


# Case study: simply-typed lambda-calculus

<!-- (CH: Any way I could have imported the exising code here without duplicating it? -->
<!--   Without a way to do this maintaining this document and keeping it consistent -->
<!--   will be a nightmare.) -->

[sf-stlc]: http://www.cis.upenn.edu/~bcpierce/sf/current/Stlc.html
[sf-stlc-prop]: http://www.cis.upenn.edu/~bcpierce/sf/current/StlcProp.html

We now look at a larger case study: proving the soundness of a type-checker
for the simply-typed $\lambda$-calculus (STLC). If you're not familiar with
STLC, you can have a look at the [Software Foundations book][sf-stlc] for
a gentle introduction given by the textual explanations (you can ignore
the Coq parts there). The formalization and proof here closely follows
the one in [Software Foundations][sf-stlc-prop]. Our proofs are, however,
shorter and much more readable than Coq proofs.

## Syntax

We represent STLC types by the F* inductive datatype `ty`.
```
type ty =
  | TBool  : ty
  | TArrow : ty -> ty -> ty
```
We consider Booleans as the only base type (`TBool`).
Function types are represented by the `TArrow` constructor taking two
type arguments. For instance we write `TArrow TBool TBool` for the type
of functions taking a Boolean argument and returning a Boolean result.
This would be written as `bool -> bool` in F* syntax, and
$\mathsf{bool} \to \mathsf{bool}$ in paper notation.

We represent the expressions of STLC by the datatype `exp`.
```
type exp =
  | EVar   : int -> exp
  | EApp   : exp -> exp -> exp
  | EAbs   : int -> ty -> exp -> exp
  | ETrue  : exp
  | EFalse : exp
  | EIf    : exp -> exp -> exp -> exp
```
Variables are represented as integer "names" decorated by the constructor `EVar`.
Variables are "bound" by lambda abstractions (`EAbs`).
For instance the identity function on Booleans is written `EAbs 0 TBool (EVar 0)`.
In paper notation one would write this function as $(\lambda x:\mathsf{bool}.~x)$.
The type annotation on the argument (`TBool`) allows for very simple type-checking.
We are not considering type inference here, to keep things simple.
The expression that applies the identity function to the `ETrue` constant is written
```
EApp (EAbs 0 TBool (EVar 0)) ETrue
```
(in paper notation $(\lambda x:\mathsf{bool}.~x)~\mathsf{true}$).

The language also has a conditional construct (if-then-else).
For instance, the Boolean "not"
function can be written as
```
EAbs 0 TBool (EIf (EVar 0) EFalse ETrue)
```
(in paper notation
$\lambda x:\mathsf{bool}.~\mathsf{if }~x~\mathsf{ then~false~else~true}$).

## Operational semantics

We define a standard small-step call-by-value interpreter for STLC.
The final result of successfully evaluating an expression is
called a _value_. We postulate that functions and the Boolean
constants are values by defining `is_value`,
a boolean predicate on expressions (a total function):
```
val is_value : exp -> Tot bool
let is_value e =
  match e with
  | EAbs _ _ _
  | ETrue
  | EFalse     -> true
  | _          -> false
```
The `EAbs`, `ETrue`, and `EFalse` cases share the same right-hand-side (`true`),
which is a way to prevent duplication in definitions.

In order to give a semantics to function applications we define a
function `subst x e e'` that substitutes `x` with `e` in `e'`:
```
val subst : int -> exp -> exp -> Tot exp
let rec subst x e e' =
  match e' with
  | EVar x' -> if x = x' then e else e'
  | EAbs x' t e1 ->
      EAbs x' t (if x = x' then e1 else (subst x e e1))
  | EApp e1 e2 -> EApp (subst x e e1) (subst x e e2)
  | ETrue -> ETrue
  | EFalse -> EFalse
  | EIf e1 e2 e3 -> EIf (subst x e e1) (subst x e e2) (subst x e e3)
```
We traverse the expression and
when we reach a variable `(EVar x')` we check whether this is the variable
`x` we want to substitute, and if it is we replace it by `e`.
For lambda abstractions `(EAbs x' t e1)` we only substitute inside the body
`e1` if `x` and `x'` are different; if they are the same we leave the body unchanged.
The reason for this is that the `x` in `e1` is bound by the abstraction:
it is a new, local name that just happens to be spelled the same as some
global name `x`. The global `x` is no longer accessible in this scope, since
it is shadowed by the local `x`. The other cases are straightforward.

> _Note for experts: Because we will only reduce closed expressions,
  where all variables
  are bound by previous lambdas, we will ever only substitute closed
  expressions (closed values in fact), and this naive definition of
  substitution is good enough. Substitution would become trickier to define
  or the representation of variables would have to change if we were considering
  the case where e, the expression replacing a variable in
  some other expression, may itself contain free variables._

Given the definition of values and of substitution we can now define
a small-step interpreter, as a function `step` that takes an expression `e`
and it either returns the expression to which `e` reduces in
a single step, or it returns `None` in case of an error
(all errors in this language are typing errors, and will be prevented
 statically by the type system).
```
val step : exp -> Tot (option exp)
  let rec step e =
  match e with
  | EApp e1 e2 ->
      if is_value e1 then
        if is_value e2 then
          match e1 with
          | EAbs x t e' -> Some (subst x e2 e')
          | _           -> None
        else
          match (step e2) with
          | Some e2' -> Some (EApp e1 e2')
          | None     -> None
      else
        (match (step e1) with
        | Some e1' -> Some (EApp e1' e2)
        | None     -> None)
  | EIf e1 e2 e3 ->
      if is_value e1 then
        match e1 with
        | ETrue   -> Some e2
        | EFalse  -> Some e3
        | _       -> None
      else
        (match (step e1) with
        | Some e1' -> Some (EIf e1' e2 e3)
        | None     -> None)
  | _ -> None

```
We execute an application expression `EApp e1 e2` in multiple steps by first reducing
`e1` to a value, then reducing `e2` to a value, and if additionally `e1`
is an abstraction `EAbs x t e' `we continue by substituting the formal
argument `x` by the actual argument `e2`. If not we signal a dynamic typing error
(a non-functional value is applied to arguments) by returning `None`.
For `EIf e1 e2 e3` we first reduce the guard `e1`: if the guard reduces to `true`
then we continue with `e2`, if the guard reduces to `false` we continue with `e3`,
and if the guard reduces to something else (e.g. a function) we report a
dynamic typing error. The `None -> None` cases simply propagate errors to
the top level.
```
assert (step (EApp (EAbs 0 TBool (EVar 0))) ETrue)) = Some ETrue)
assert (step (EApp ETrue ETrue) = None)
```

## Type-checker

In order to assign a type to a term, we need to know what assumptions
we should make about the types of its free variables. So typing
happens with respect to a typing environment---a mapping from the
variables in scope to their types. We represent such partial maps as
functions taking an integer variable name and returning an optional type:
```
type env = int -> Tot (option ty)
```
We start type-checking closed terms in the empty environment,
i.e. initially no variables are in scope.
```
val empty : env
let empty _ = None
```
When we move under a binder we extend the typing environment environment.
```
val extend : env -> int -> ty -> Tot env
let extend g x t x' = if x = x' then Some t else g x'
```
For instance we type-check `EAbs x t e` in typing environment `g` by
first type-checking the body `e` in the environment `extend g x t`.

The type-checker is a total function taking an environment `g` and an expression `e`
and producing either the type of `e` or `None` if `e` is not well-typed.

```
val typing : env -> exp -> Tot (option ty)
let rec typing g e =
  match e with
  | EVar x -> g x
  | EAbs x t e1 ->
      (match typing (extend g x t) e1 with
      | Some t' -> Some (TArrow t t')
      | None    -> None)
  | EApp e1 e2 ->
      (match typing g e1, typing g e2 with
      | Some (TArrow t11 t12), Some t2 -> if t11 = t2 then Some t12 else None
      | _                    , _       -> None)
  | ETrue  -> Some TBool
  | EFalse -> Some TBool
  | EIf e1 e2 e3 ->
      (match typing g e1, typing g e2, typing g e3 with
      | Some TBool, Some t2, Some t3 -> if t2 = t3 then Some t2 else None
      | _         , _      , _       -> None)
```
Variables are simply looked up in the environment.
For abstractions `EAbs x t e1` we type-check the body `e1` under the
environment `extend g x t`, as explained above. If that succeeds and
produces a type `t'`, then the whole abstraction is given type `TArrow t t'`.
For applications `EApp e1 e2` we type-check `e1` and `e2` separately, and
if `e1` has a function type `TArrow t11 t12` and
`e2` has type `t11`, then the whole application has type `t12`.
`ETrue` and `EFalse` have type `TBool`.
For conditionals, we require that the guard has type `TBool` and
the two branches have the same type, which is also the type of the conditional.

## Soundness proof

<!-- (CH: I generally find giving people finished proofs uninformative and unhelpful. -->
<!-- This seems like something to do from scratch in an emacs buffer. Trying to capture -->
<!-- that kind of interaction in the current format seems very hard.) -->

We prove progress and preservation for STLC.
The **progress** theorem tells us that closed, well-typed terms do not produce
(immediate) dynamic typing errors: either a well-typed term is a value,
or it can take an evaluation step.
The proof is a relatively straightforward induction.
```
val progress : e:exp -> Lemma
      (requires (is_Some (typing empty e)))
      (ensures (is_value e \/ (is_Some (step e))))
let rec progress e =
  match e with
  | EApp e1 e2 -> progress e1; progress e2
  | EIf e1 e2 e3 -> progress e1; progress e2; progress e3
  | _ -> ()
```
Variables are not well-typed in the empty environment,
so the theorem holds vacuously for variables.
Boolean constants and abstractions are values,
so the theorem holds trivially for these.
All these simple cases are proved automatically by F\*.
For the remaining cases we need to use the induction hypothesis,
but otherwise the proofs are fully automated.
Under the hood F\* and Z3 are doing quite a bit of work though.

In case `e = (EApp e1 e2)` F\* and Z3 automate the following intuitive argument:
We case split on the first instance of the induction
hypothesis `(is_value e1 \/ (is_Some (step e1)))`.

* If `e1` steps to `e1'` then, by the definition of `step`,
`(EApp e1 e2)` steps to `(EApp e1' e2)`.
* If `e1` is a value, we case split on the second induction hypothesis instance,
``(is_value e2 \/ (is_Some (step e2)))``.
  * If `e2` steps to `e2'` then `(EApp e1 e2)` steps to `(EApp e1 e2')`,
  since `e1` is a value.
  * If `e2` is also a value, then we need to obtain that `e1` has
    a function type and from this that it is an abstraction.
    Expression `e1` has a function type because, by the definition of `typing`,
    an application is well-typed only when the first expression is a function.
    The remaining step is usually done as a separate "canonical forms" lemma, stating
    that any value that has a function type is actually an abstraction.
    Z3 can prove this fact automatically from the definitions of `typing`
    and `is_value`.

The intuitive proof of the `EIf` case is similar.

<!--
Using the _experimental_ support for automatic induction ([#auto-ind]),
the proof above can be written as just:
```
let rec progress e = by_induction_on e progress
```
-->

The **preservation** theorem (sometimes also called "subject reduction") states that
when a well-typed expression takes a step, the result is a well-typed expression
of the same type.
In order to show preservation we need to prove a couple of auxiliary results
for reasoning about variables and substitution.

The case for function application has to reason about "beta reduction" steps,
i.e. substituting the formal argument of a function with an actual value.
To see that this step preserves typing, we need to know that the
substitution itself does. So we prove a **substitution** lemma, stating that
substituting a (closed) term `v` for a variable `x` in an expression `e` preserves
the type of `e`. The tricky cases in the substitution proof
are the ones for variables and for function abstractions.
In both cases, we discover that we need to take an expression `e` that has been shown
to be well-typed in some context `g` and consider the same expression `e` in a
slightly different context `g'`. For this we prove a **context invariance** lemma,
showing that typing is preserved under "inessential changes" to the context `g`---in
particular, changes that do not affect any of the free variables of the expression.
For this, we need a definition of the free variables of an expression---i.e.,
the variables occurring in the expression that are not bound by an abstraction.

A variable `x` appears free in `e` if `e` contains some occurrence of `x`
that is not under an abstraction labeled `x`:
```
val appears_free_in : x:int -> e:exp -> Tot bool
let rec appears_free_in x e =
  match e with
  | EVar y -> x = y
  | EApp e1 e2 -> appears_free_in x e1 || appears_free_in x e2
  | EAbs y _ e1 -> x <> y && appears_free_in x e1
  | EIf e1 e2 e3 ->
      appears_free_in x e1 || appears_free_in x e2 || appears_free_in x e3
  | ETrue
  | EFalse -> false
```

We also need a technical lemma connecting free variables and typing contexts.
If a variable `x` appears free in an expression `e`,
and if we know that `e` is well typed in context `g`,
then it must be the case that `g` assigns some type to `x`.
```
val free_in_context : x:int -> e:exp -> g:env -> Lemma
      (requires (is_Some (typing g e)))
      (ensures (appears_free_in x e ==> is_Some (g x)))
let rec free_in_context x e g =
  match e with
  | EVar _
  | ETrue
  | EFalse -> ()
  | EAbs y t e1 -> free_in_context x e1 (extend g y t)
  | EApp e1 e2 -> free_in_context x e1 g; free_in_context x e2 g
  | EIf e1 e2 e3 -> free_in_context x e1 g;
                    free_in_context x e2 g; free_in_context x e3 g
```
The proof is a straightforward induction.
As a corollary for `g=empty` we obtain that expressions typable
in the empty environment have no free variables.
```
val typable_empty_closed : x:int -> e:exp -> Lemma
      (requires (is_Some (typing empty e)))
      (ensures (not(appears_free_in x e)))
      [SMTPat (appears_free_in x e)]
let typable_empty_closed x e = free_in_context x e empty
```
The quantifier pattern `[SMTPat (appears_free_in x e)]` signals F\*
that it should feed this lemma to the SMT solver using this pattern.

Sometimes, we know that `typing g e = Some t`,
and we will need to replace `g` by an "equivalent" context `g'`.
We still need to define formally when two environments are equivalent.
A natural definition is extensional equivalence of functions:
```
opaque logic type Equal (g1:env) (g2:env) =
                 (forall (x:int). g1 x = g2 x)
```
According to this definition two environments are equivalent if have
the same domain and they map all variables in the domain to the same type.
We remark `Equal` in particular and logical formulas in general
are "types" in F\*, thus the different syntax for this definition.
~CH
What does opaque do exactly?
What does logic do?
Hints for the SMT solver / logical encoding only?
~

The context invariance lemma uses in fact a weaker variant of this equivalence
in which the two environments only need to agree on the variables that appear free
in an expression `e`:
```
opaque logic type EqualE (e:exp) (g1:env) (g2:env) =
                 (forall (x:int). appears_free_in x e ==> g1 x = g2 x)
```
The context invariance lemma is then easily proved by induction:
```
val context_invariance : e:exp -> g:env -> g':env
                     -> Lemma
                          (requires (EqualE e g g'))
                          (ensures (typing g e == typing g' e))
let rec context_invariance e g g' =
  match e with
  | EAbs x t e1 ->
     context_invariance e1 (extend g x t) (extend g' x t)

  | EApp e1 e2 ->
     context_invariance e1 g g';
     context_invariance e2 g g'

  | EIf e1 e2 e3 ->
     context_invariance e1 g g';
     context_invariance e2 g g';
     context_invariance e3 g g'

  | _ -> ()
```
Because `Equal` is a stronger relation than `EqualE` we obtain the same property
for `Equal`:
```
val typing_extensional : g:env -> g':env -> e:exp -> Lemma
                           (requires (Equal g g'))
                           (ensures (typing g e == typing g' e))
let typing_extensional g g' e = context_invariance e g g'
```
We can use these results to show the following substitution lemma:
```
val substitution_preserves_typing : x:int -> e:exp -> v:exp ->
      g:env -> Lemma
        (requires ( is_Some (typing empty v) /\
              is_Some (typing (extend g x (Some.v (typing empty v))) e)))
        (ensures (is_Some (typing empty v) /\
                  typing g (subst x v e) ==
                  typing (extend g x (Some.v (typing empty v))) e))
let rec substitution_preserves_typing x e v g =
  let Some t_x = typing empty v in
  let gx = extend g x t_x in
  match e with
  | ETrue -> ()
  | EFalse -> ()
  | EVar y ->
     if x=y
     then context_invariance v empty g (* uses lemma typable_empty_closed *)
     else context_invariance e gx g

  | EApp e1 e2 ->
     substitution_preserves_typing x e1 v g;
     substitution_preserves_typing x e2 v g

  | EIf e1 e2 e3 ->
     substitution_preserves_typing x e1 v g;
     substitution_preserves_typing x e2 v g;
     substitution_preserves_typing x e3 v g

  | EAbs y t_y e1 ->
     let gxy = extend gx y t_y in
     let gy = extend g y t_y in
     if x=y
     then typing_extensional gxy gy e1
     else
       (let gyx = extend gy x t_x in
        typing_extensional gxy gyx e1;
        substitution_preserves_typing x e1 v gy)
```
The proof proceeds by induction on the expression `e`;
we give the intuition of the two most interesting cases:

* Case `e = EVar y`
  * Case `x = y`: We have `subst x v e = v` and we already know that
    `typing empty v == Some t_x`. However, what we need to show is
    `typing g v == Some t_x` for some arbitrary environment `g`.
    From the `typable_empty_closed` lemma we obtain that `v` contains
    no free variables, so we have `EqualE v empty g`. This allows us
    to apply the `context_invariance` lemma to obtain that
    `typing empty v = typing g v` and complete the proof of this case.
  * Case `x <> y`: We have `subst x v e = e` and
    `typing gx e = Some t_e` and need to show that
```
typing g e = Some t_e
```
    We have that `EquivE (EVar y) gx g` since `x <> y` so we can apply
    the `context_invariance` lemma to conclude.
* Case `e = EAbs y t_y e1`:
  We have that `typing gxy e1 = Some t_e1`,
  and need to show that
```
typing gy e1 = Some t_e1
```
  * Case `x = y`: We have `subst x v e = EAbs y t_y e1`.
    Since `x = y` the `x` binder in `gxy` is spurious (we have `Equal gy gxy`)
    and can apply the `typing_extensional` lemma.
  * Case `x <> y`: We have `subst x v e = EAbs y t_y (subst x v e1)`.
    Since `x <> y` (and since we are in a simply typed calculus, not
    a dependently typed one) we can swap the `x` and `y` binding to show
    that `Equal gxy xyx`. By the `typing_extensional` lemma we obtain that
    `typing gxy e1 == typing gyx e1`. By the induction hypothesis we thus
    obtain that
```
typing gy (subst x v e1) == Some t_e1
```
    and by the definition
    of `typing` we conclude that `typing g (EAbs y t_y (subst x v e)) = t_e`.

We now have the tools we need to prove preservation:
if a closed expression `e` has type `t` and takes an evaluation step to `e'`,
then `e'` is also a closed expression with type `t`.
In other words, the small-step evaluation relation preserves types.
```
val preservation : e:exp -> Lemma
        (requires(is_Some (typing empty e) /\ is_Some (step e) ))
        (ensures(is_Some (step e) /\
                 typing empty (Some.v (step e)) == typing empty e))
let rec preservation e =
  match e with
  | EApp e1 e2 ->
     if is_value e1
     then (if is_value e2
           then let EAbs x _ ebody = e1 in
                substitution_preserves_typing x ebody e2 empty
           else preservation e2)
     else preservation e1

  | EIf e1 _ _ ->
      if not (is_value e1) then preservation e1
```
We only have two cases to consider, since only applications and conditionals
can take successful execution steps. The case for `e = EIf e1 e2 e3` is simple:
either `e1` is a value and thus the conditional reduces to `e2` or `e3` which
by the typing hypothesis also have type `t`, or `e1` takes a successful step and
we can apply the induction hypothesis. We use the `Some.v` projector for options
with the following type:
```
  Some.v : x:(option 'a){is_Some x} -> Tot 'a
```
which requires F\* to prove that indeed `e1` can take a step;
this is immediate since we know that the whole conditional takes a step
and we know that `e1` is not a value.

The case for `e = EApp e1 e2` is a bit more complex. If `e1` steps or if `e1` is
a value and `e2` steps then we just apply the induction hypothesis.
If both `e1` and `e2` are values it needs to be the case that `e1` is
an abstraction `EAbs x targ ebody` and `step e = subst x e2 ebody`.
From the typing assumption we have `typing (extend empty x tags) ebody = Some t`
and `typing empty e2 = Some targ`, so we can use the substitution lemma
to obtain that `typing empty (subst x e2 ebody) = Some t`, which concludes the proof.

## Exercises for STLC

~ Exercise
Define a `typed_step` step function that takes a
well-typed expression `e` that is not a value and
produces the expression to which `e` steps. Give `typed_step`
the following strong type
(basically this type captures both progress and preservation):
~~ ExerciseFragment {exname=ex7a-stlc-typed-step}
  val typed_step : e:exp{is_Some (typing empty e) /\ not(is_value e)} ->
                   Tot (e':exp{typing empty e' = typing empty e})
~~
(Hint: the most direct solution to this exercise fits on one line)
~~ AnswerFragment {exname=ex7a-stlc-typed-step}
    let typed_step e = progress e; preservation e; Some.v (step e)
~~
~

~ Exercise
To add pairs to this formal development we add the following to the
definition of types, expressions, values, substitution, and step:
~~ ExerciseFragment {exname=ex7b-stlc-pairs}
type ty =
  ...
  | TPair : ty -> ty -> ty

type exp =
  ...
  | EPair  : exp -> exp -> exp
  | EFst   : exp -> exp
  | ESnd   : exp -> exp
~~
(note the extra rec in `is_value` below!)
~~ ExerciseFragment {exname=ex7b-stlc-pairs}
let rec is_value e =
  match e with
  ...
  | EPair e1 e2 -> is_value e1 && is_value e2

let rec subst x e e' =
  match e' with
  ...
  | EPair e1 e2 -> EPair (subst x e e1) (subst x e e2)
  | EFst e1 -> EFst (subst x e e1)
  | ESnd e1 -> ESnd (subst x e e1)

let rec step e =
  ...
  | EPair e1 e2 ->
      if is_value e1 then
        if is_value e2 then None
        else
          (match (step e2) with
          | Some e2' -> Some (EPair e1 e2')
          | None     -> None)
      else
        (match (step e1) with
        | Some e1' -> Some (EPair e1' e2)
        | None     -> None)
  | EFst e1 ->
      if is_value e1 then
        (match e1 with
        | EPair v1 v2 -> Some v1
        | _           -> None)
      else
        (match (step e1) with
        | Some e1' -> Some (EFst e1')
        | None     -> None)
  | ESnd e1 ->
      if is_value e1 then
        (match e1 with
        | EPair v1 v2 -> Some v2
        | _           -> None)
      else
        (match (step e1) with
        | Some e1' -> Some (ESnd e1')
        | None     -> None)
~~
Add cases to `typing` for the new constructs and fix all the proofs.

~~ Answer
We extend the `typing` and `appears_free_in` functions with cases
for `EPair`, `EFst`, and `ESnd`:
~~~ SolutionFragment {exname=ex7b-stlc-pairs}
val typing : env -> exp -> Tot (option ty)
let rec typing g e =
...
  | EPair e1 e2 ->
      (match typing g e1, typing g e2 with
      | Some t1, Some t2 -> Some (TPair t1 t2)
      | _      , _       -> None)
  | EFst e1 ->
      (match typing g e1 with
      | Some (TPair t1 t2) -> Some t1
      | _                  -> None)
  | ESnd e1 ->
      (match typing g e1 with
      | Some (TPair t1 t2) -> Some t2
      | _                  -> None)

val appears_free_in : x:int -> e:exp -> Tot bool
...
  | EPair e1 e2 -> appears_free_in x e1 || appears_free_in x e2
  | EFst e1 -> appears_free_in x e1
  | ESnd e1 -> appears_free_in x e1
~~~
The proofs of the lemmas are also easy to extend by just calling
the induction hypothesis:
~~~ SolutionFragment {exname=ex7b-stlc-pairs}
val free_in_context : x:int -> e:exp -> g:env -> Lemma
      (requires (is_Some (typing g e)))
      (ensures (appears_free_in x e ==> is_Some (g x)))
let rec free_in_context x e g =
...
  | EPair e1 e2 -> free_in_context x e1 g; free_in_context x e2 g
  | EFst e1
  | ESnd e1 -> free_in_context x e1 g

val context_invariance : e:exp -> g:env -> g':env
                     -> Lemma
                          (requires (EqualE e g g'))
                          (ensures (typing g e == typing g' e))
let rec context_invariance e g g' =
...
| EPair e1 e2 ->
     context_invariance e1 g g';
     context_invariance e2 g g'

  | EFst e1
  | ESnd e1 -> context_invariance e1 g g'

val substitution_preserves_typing : x:int -> e:exp -> v:exp ->
      g:env{is_Some (typing empty v) &&
            is_Some (typing (extend g x (Some.v (typing empty v))) e)} ->
      Tot (u:unit{typing g (subst x v e) ==
                  typing (extend g x (Some.v (typing empty v))) e})
let rec substitution_preserves_typing x e v g =
...
  | EPair e1 e2 ->
     (substitution_preserves_typing x e1 v g;
      substitution_preserves_typing x e2 v g)

  | EFst e1
  | ESnd e1 ->
      substitution_preserves_typing x e1 v g
~~~
As for the other cases, the preservation proof when `e = EPair e1 e2`
follows the structure of the `step` function. If `e1` is not a value
then it further evaluates, so we apply the induction hypothesis to
`e1`.  If `e1` is a value, then since we know that the pair evaluates,
it must be the case that `e2` is not a value and further evaluates, so
we apply the induction hypothesis to it. The cases for `EFst` and
`ESnd` are similar.
~~~ SolutionFragment {exname=ex7b-stlc-pairs}
val preservation : e:exp{is_Some (typing empty e) /\ is_Some (step e)} ->
      Tot (u:unit{typing empty (Some.v (step e)) == typing empty e})
let rec preservation e =
...
  | EPair e1 e2 ->
      (match is_value e1, is_value e2 with
      | false, _     -> preservation e1
      | true , false -> preservation e2)

  | EFst e1
  | ESnd e1 ->
      if not (is_value e1) then preservation e1
~~~
~~
~

<!--
(CH: Quite a lot of stuff to add to the definitions, maybe just
 give them all that code, or at least the step extension.
 Otherwise they can get it wrong (I did) and have a hard time in the proofs.)
-->

<!--
_Exercise: Add arithmetic expressions to this formal development.
Copy the stlc.fst file and add the following to the definition of
types and expressions (`EIf0` tests if a number is zero or not):_
```
type ty =
  ...
  | TNat : ty

type exp =
  ...
  | ENat  : nat -> exp
  | EPlus : exp -> exp -> exp
  | EIf0  : exp -> exp -> exp -> exp
```
(CH: The pairs and arithmetic exercises are rather similar, so just do one of them.
None of them is very interesting from a proof point of view.)
-->

~ Exercise
We want to add a let construct to this formal development.
We add the following to the definition of expressions:
~~ ExerciseFragment {exname=ex7c-stlc-let}
type exp =
  ...
  | ELet  : int -> exp -> exp -> exp
~~
Add cases for `ELet` to all definitions and proofs.

[Load answer in editor](code/solutions/ex7c-stlc-let.fst)
~~ CH
Make the prev kind of link a macro of some sorts. It doesn't have a
proper body so it's not an environment, but what is it? Entity?
~~
~

~ Exercise
Define a big-step interpreter for STLC as a recursive
function `eval` that given a well-typed expression `e`
either produces the well-typed value `v` to which `e` evaluates
or it diverges if the evaluation of `e` loops. Give `eval` the following
strong type ensuring that `v` has the same type as `e`
(basically this type captures both progress and preservation):
~~ ExerciseFragment {exname=ex7d-stlc-eval}
  val eval : e:exp{is_Some (typing empty e)} ->
             Dv (v:exp{is_value v && typing empty v = typing empty e})
~~
The `Dv` effect is that of potentially divergent computations.
We cannot mark this as `Tot` since a priori STLC computations could loop,
and it is hard to prove that well-typed ones don't, while defining an
interpreter.
~~Answer
Here is a solution that only uses `typed_step` (suggested by Santiago Zanella):
~~~ SolutionFragment {exname=ex7d-stlc-eval}
val eval : e:exp{is_Some (typing empty e)} ->
           Dv (v:exp{is_value v && typing empty v = typing empty e})
let rec eval e =
  if is_value e then e
  else eval (typed_step e)
~~~
or using the `progress` and `preservation` lemmas instead of `typed_step`
(suggested by Guido Martinez):
```
val eval : e:exp{is_Some (typing empty e)} ->
  Dv (v:exp{is_value v && typing empty v = typing empty e})
let rec eval e = match step e with
  | None -> progress e; e
  | Some e' -> preservation e; eval e'
```
Here is another solution that only uses the substitution lemma:
~~~ SolutionFragment {exname=ex7d-stlc-eval}
val eval' : e:exp{is_Some (typing empty e)} ->
            Dv (v:exp{is_value v && typing empty v = typing empty e})
let rec eval' e =
  let Some t = typing empty e in
  match e with
  | EApp e1 e2 ->
     (let EAbs x _ e' = eval' e1 in
      let v = eval' e2 in
      substitution_preserves_typing x e' v empty;
      eval' (subst x v e'))
  | EAbs _ _ _
  | ETrue
  | EFalse     -> e
  | EIf e1 e2 e3 ->
     (match eval' e1 with
      | ETrue  -> eval' e2
      | EFalse -> eval' e3)
  | EPair e1 e2 -> EPair (eval' e1) (eval' e2)
  | EFst e1 ->
     let EPair v1 _ = eval' e1 in v1
  | ESnd e1 ->
     let EPair _ v2 = eval' e1 in v2
  | ELet x e1 e2 ->
     (let v = eval' e1 in
      substitution_preserves_typing x e2 v empty;
      eval' (subst x v e2))
~~~
~~
~

<!-- Relating small step and big step is hard and boring
val steps_n : nat -> exp -> Tot (option exp)
let rec steps_n n e =
  match n with
  | 0 -> Some e
  | _ -> (match step e with
          | Some e' -> steps_n (n-1) e'
          | _       -> None)

opaque logic type Steps (e:exp) (e':exp) =
  (exists (n:nat). steps_n n e == Some e')

assume val step_last : e:exp -> e':exp -> e'':exp -> Lemma
             (requires (Steps e e' /\ step e' = Some e''))
             (ensures (Steps e e''))

val eval : e:exp{is_Some (typing empty e)} ->
           Dv (v:exp{is_value v && typing empty v = typing empty e
                     /\ Steps e v}) --- added this
-->
<!--
_Exercise: Extend the type-checker so that it produces error messages in case
of ill-typed terms, instead of just `None`_
(CH: boring programming exercise? nothing to do with proving/verifying)

_Exercise: Change the step and typing functions to use primitive exceptions
instead of options_ (CH: Not sure this is solvable with the current F\*,
but it seems quite interesting)
-->

# Higher kinds, indexed types, implicit arguments, and type-level functions

So far, we have mostly programmed total functions and give them
specifications using rich types. Under the covers, F\* has a second
level of checking at work to ensure that the specifications that you
write are also meaningful---this is F\*'s kind system. Before moving
on to more advanced F\* features, you'll have to understand the kind
system a little. In short, just as types describe properties of
programs, kinds describe properties of types.

## `Type`: The type of types

The basic construct in the kind system is the constant `Type`, which
is the basic type of a type. For example,
just as we say that `0 : int` (zero has type `int`), we also say
`int : Type` (`int` has kind `Type`), `bool : Type`, `nat : Type` etc.

## Arrow kinds

Beyond the base types, consider types like `list int`, `list bool`
etc.  These are also types, of course, and in F\* `list int : Type`
and `list bool : Type`. But, what about the unapplied type
constructor `list`---it's not a `Type` on its own; it only produces a
`Type` when applied to a `Type`. In that sense, `list` is type
constructor. To describe this, just as we use the `->` type
constructor to describe functions at the level of programs, we use the
`->` kind constructor to describe functions at the level of types. As
such, we write `list : Type -> Type`, meaning that it produces a
`Type` when applied to a `Type`.

## Indexed types and implicit arguments

Beyond inductive types like `list`, F\* also supports inductive type
families, or [GADTs]. For example, here is one definition of a
`vector`, a length-indexed list.

```
type vector : Type -> nat -> Type =
   | Nil :  vector 'a 0
   | Cons : hd:'a -> n:nat -> tl:vector 'a n -> vector 'a (n + 1)
```

Here, we define a type constructor `vector : Type -> nat -> Type`,
which takes two arguments: it produces a `Type` when applied first to
a `Type` and then to a `nat`.

The point is to illustrate that just as functions at the level of
programs may take either type- or term-arguments, types themselves can
take either types or pure expressions as arguments.

[GADTs]: https://en.wikipedia.org/wiki/Generalized_algebraic_data_type

### Implicit arguments

When writing functions over terms with indexed types, it is convenient
to mark some arguments as implicit, asking the type-checker to infer
them rather than having to provide them manually.

For example, the type of a function that reverses a vector can be
written as follows:

```
val reverse_vector: #a:Type -> #n:nat -> vector a n -> Tot (vector a n)
```

This indicates that `reverse_vector` expects three arguments, but the
`#` sign mark the first two arguments as implicit. Given a term
`v : vector t m`, simply writing `reverse_vector v` will type-check as
`vector t m`---internally, F\* elaborates the function call to
`reverse_vector #t #m v`, instantiating the two implicit arguments
automatically. To view what F\* inferred, you can provide the
`--print_implicits` argument to the compiler, which will cause all
implicitly inferred arguments to be shown in any message from the
compiler. Alternatively, you can write `reverse_vector #t #m v`
yourself to force the choice of implicit arguments manually.

When you write a type like `'a -> M t wp` (note the "ticked" variable
`'a`), this is simply syntactic sugar for `#a:Type -> a -> M t wp`,
with every occurrence of `'a` replaced by `a` in `M t wp`---in other
words, the "ticked" type variable is an implicit type argument. With
this in mind, the definition of `vector` is desugared to:

```
type vector : Type -> nat -> Type =
   | Nil :  #a:Type -> vector a 0
   | Cons : #a:Type -> hd:a -> n:nat -> tl:vector a n -> vector a (n + 1)
```

One could go further and also define the `Cons` constructor's `n`
argument to be implicit, like so:

```
type vector : Type -> nat -> Type =
   | Nil :  #a:Type -> vector a 0
   | Cons : #a:Type -> hd:a -> #n:nat -> tl:vector a n -> vector a (n + 1)
```

With this, given `v: vector int m`, we can write `Cons 0 v` to build a
`vector int (m + 1)`.

## Dependent kind arrows and type function

Even some of the built-in type constructors can be given
kinds. Consider the refinement type constructor: `_:_{_}`, whose
instances include types we've seen before, like `x:int{x >= 0}`, which
is the type `nat`, of course.  With less syntactic sugar, you can view
the type `x:int{phi(x)}` as the application of a type constructor
`refinement` to two arguments `int` and a refinement formula
`fun x -> phi(x)`. As discussed in Section [#sec-bool-versus-type], the formula
`phi(x)` is itself a `Type`. Thus, the kind of the `refinement`
constructor is `a:Type -> (a -> Type) -> Type`, meaning it takes two
arguments; first, a type `a`; then a second argument, a predicate on
`a` (whose kind depends on `a`); and then bulids a `Type`.

The type `fun x -> phi(x)` is type function, a lambda abstraction at
the level of types, which when applied to a particular value, say,
`0`, reduces as usual to `phi(0)`.

## Kind abbreviations

F\* allows top-level declarations to define abbreviations for kinds. For example,
one can write:

```
kind Predicate (a:Type) = a -> Type
```

Now, the kind `Predicate a` is an abbreviation for `a -> Type`.

# Specifying effects

~CH
This seems like super advanced stuff that should come a lot
later in the tutorial. How about swapping 2 references first?
(have a couple of such simple examples in the Saarbrucken course)
~

F\* provides a mechanism to define new effects. As mentioned earlier,
the system is already configured with several basic effects, including
non-termination, state and exceptions.  In this section, we look
briefly at how effects are defined, using the `PURE` and `STATE`
effects for illustration.

On a first reading, you may wish to skip this section and proceed
directly to the next chapter.


## Background: Generating compact verification conditions

Type inference in F\* is based on a weakest pre-condition calculus for
higher order programs. For every term `e`, F\* computes `WP e`, which
captures the semantics of `e` as a _predicate transformer_. If you want
to prove some property `P` about the result of `e` (i.e., a
post-condition), it suffices to prove `WP e P` of the initial
configuration in which `e` is executed (i.e., a pre-condition).

Let's start by considering a very simple, purely functional
programming language with only the following forms:

```
b ::= x | true | false
e ::= b | let x = e1 in e2 | assert b | if b then e1 else e2
```

For this tiny language, the post-conditions `P` that you may want to
prove are predicates on the boolean results of a computation, while
the pre-conditions are just propositions. Defining `WP e` for this
language is fairly straightforward:

```
WP b P                      = P b
WP (let x = e1 in e2) P     = WP e1 (fun x -> WP e2 P)
WP (assert b) P             = b /\ P b
WP (if b then e1 else e2) P = (b ==> WP e1 P) /\ ((not b) ==> WP e2 P)
```

This is nice and simple, but it has a significant drawback,
particularly in the fourth rule: the post-condition formula `P` is
duplicated across the branches. As several branching expressions are
sequenced, this leads to an exponential blowup in the size of the
verification condition.

This problem with WP computations is well known---[Flanagan and Saxe]
and [Leino] both study this problem and provide equivalent
solutions. In essence, they show that for a first-order,
assignment-free guarded command language the weakest pre-condition can
be computed in a size nearly linear in the size of the program. Then,
they show that first-order imperative WHILE language can be converted
into SSA form and then into a guarded command language.

[Flanagan and Saxe]: http://dl.acm.org/citation.cfm?id=360220
[Leino]: http://dl.acm.org/citation.cfm?id=1710882

In the context of F\*, we generalize the results of Flanagan and Saxe,
and Leino, to the setting of a higher-order language. The main
technical idea is a new "Double [Dijkstra Monad]". Given a program, F\*
infers a monadic computation type indexed by (1) a WP, the weakest
pre-condition predicate transformer; and (2) a WLP, the weakest
liberal pre-condition predicate transformer. Intuitively, `WLP e Q` is
sufficient to guarantee that if `e` contains no internal assertion
failures, then its result satisfies `P`; in contrast, the `WP e P` is
sufficient to guarantee both that `e`'s internal assertions succeed and
that its result satisfies `P`.

Here's the definition of `WLP` for our small example langauge.

```
WLP b P                      = P b
WLP (let x = e1 in e2) P     = WLP e1 (fun x -> WLP e2 P)
WLP (assert b) P             = b ==> P b
WLP (if b then e1 else e2) P = (b ==> WLP e1 P) /\ ((not b) ==> WLP e2 P)
```

The only difference with the `WP` is in the case of assertions. For a
WLP, rather than requiring a proof of the assertion, we try to prove
the post-condition assuming the assertion succeeds.

How does this help us? Let's see.

First, you can prove the following property about `WLP`.

```
(Identity 1)
           WLP e P
      <==> forall x. P x \/ WLP e (fun y -> y <> x)
```

Here's one way to read formula (1): Proving that `P` is true of the
typed result of a computation (the LHS) is equivalent to proving that
for every `x`, we either have `P x` or we can prove that the result of
the computation is not `x` (the RHS).

Armed with identity (1) above, we can also prove the following
identity:

```
(Identity 2)
          WP e P
     <==> WP e (fun x -> True) /\ WLP e P
     <==> WP e (fun x -> True) /\ (forall x. P x \/ WLP e (fun y -> y <> x)) (by (1))
```

That is, in order to prove that a computation `e` has no internal
assertion failures and produces a result satisfying `P`, one can
equivalently prove (a) that `e` has no internal assertion failures
(i.e., `WP e (fun x -> True)`) and then prove (b) that `e`'s result
satisfies `P` (i.e, `WLP e P`).

Finally, we come back to our rule for conditional expressions, which
we can restate as follows (using identities (1) and (2)):

```
WP (if b then e1 else e2) P
=    (b ==> WP e1 (fun x -> True))
  /\ ((not b) ==> WP e2 (fun x -> True))
  /\ (forall y. P y \/ ((b ==> WLP e1 (fun x -> x<>y)
                     /\ (not b) ==> WLP e2 (fun x -> x<>y)))
```

In this form, the post-condition `P` is no longer duplicated across
the branches of the computation and we avoid the exponential blowup
(at the cost of computing both the `WP` and the `WLP`).

WPs and WLPs are convenient for type inference---for loop- and
recursion-free code, we can simply compute the most precise
verification condition for a program without further
annotation. However, programmers are often more comfortable writing
specification in terms of pre- and post-conditions, rather than
predicate transformers. As we will see shortly, computing both the WP
and the WLP allows F\* to move between the two styles without a loss
in precision (computing just the WP alone would not allow this).


## Computation types

Expressions in F\* are given _computation types_ `C`.  In its most
primitive form, each effect in F\* introduces a computation type of
the form `M t_1..t_n t wp wlp`. The `M t_1..t_n` indicates the name of the
effect `M` and several user-defined indexes `t_1..t_n`.  The type `t`
indicates the type of the result of the computation; `wp` is a
predicate transformer that is not weaker than the weakest
pre-condition of `e`; and `wlp` is a predicate transformer not weaker
than the weakest liberal pre-condition of `e`. For the sake of
brevity, we call `wp` the weakest pre-condition and `wlp` the weakest
liberal pre-condition.

For the purposes of the presentation here, we start by discussing a
simplified form of these `C` types, i.e, we will consider computation
types of the form `M t wp wlp`, those that have a non-parameterized
effect constructor `M` (and generalize to the full form towards the
end of this chapter).

A computation `e` has type `M t wp wlp` if when run in an initial
configuration satisfying `wp post`, it (either runs forever, if
allowed, or) produces a result of type `t` in a final configuration
`f` such that `post f` is true, all the while exhibiting no more
effects than are allowed by `M`. In other words, `M` is an upper bound
on the effects of `e`; `t` is its result type; and `wp` is a predicate
transformer that for any post-condition of the final configuration of
`e`, produces a sufficient condition on the initial configuration of
`e`. The `wlp` is similar, except it is liberal with respect to the
internal assertions of `e` in the sense described in the previous
section.

These computation types (specifically their predicate transformers)
form what is known as a [Dijkstra monad]. Some concrete examples
should provide better intuition.

~Remark
We follow an informal syntactic convention that the non-abbreviated
all-caps names for computation types are the primitive forms---other
forms are derived from these.

For example, the computation type constructor `PURE` is a more
primitive version of `Pure`, which we have used earlier in this
tutorial. By the end of this chapter, you will see how `Pure`, `Tot`,
etc. are expressed in terms of `PURE`. Likewiwse `STATE` is the
primitive form of `ST`; `EXN` is the primitive form of `Exn`; etc.

~

[Dijkstra monad]: http://research.microsoft.com/en-us/um/people/nswamy/papers/paper-pldi13.pdf



## The `PURE` effect

The `PURE` effect is primitive in F\*. No user should ever have to
(re-)define it. Its definition is provided once and for all in
`lib/prims.fst`. It's instructive to look at its definition inasmuch
as it provides some insight into how F\* works under the covers. It
also provides some guidance on how to define new effects. We discuss a
fragment of it here.

The type of pure computations is `PURE t wp wlp` where
`wp, wlp : (t -> Type) -> Type`. This means that pure computations produce
`t`-typed results and are decribed by predicate transformers that
transform result predicates (post-conditions of kind `t -> Type`) to
pre-conditions, which are propositions of kind `Type`.

Seen another way, the signatures of the `wp` and `wlp` have the
following form---they transform pure post-conditions to pure
pre-conditions.

```
kind PurePost (a:Type) = a -> Type
kind PurePre = Type
kind PureWP (a:Type) = PurePost a -> PurePre
```

For example, one computation type for `0` is
`PURE int return_zero return_zero` where
```
return_zero = fun (p:(int -> Type)) -> p 0
```
This means that in order to
prove any property `p` about the result of the computation `0` is
suffices to prove `p 0`---which is of course what you would
expect. The type `return_zero` is an instance of the more general form
below:

```
type return_PURE (#a:Type) (x:a) = fun (post: PurePost a) -> post x
```

When sequentially composing two pure computations using
`let x = e1 in e2`, if
`e1: PURE t1 wp1 wlp1` and
`e2: (x:t1 -> PURE t2 (wp2 x) (wlp2 x))`,
we type the composed computation as
```
PURE t2 (bind_PURE wp1 wp2) (bind_PURE wlp1 wlp2)
```
where:
```
type bind_PURE (#a:Type) (#b:Type)
               (wp1: PureWP a)
               (wp2: a -> PureWP b)
 = fun (post:PurePost b) -> wp1 (fun (x:a) -> wp2 x post)
```

One can show that `return_PURE` and `bind_PURE` together form a monad.

### `Pure` and `Tot`

The `Pure` effect is an abbreviation for `PURE` that allows you to
write specifications with pre- and post-conditions instead of
predicate transformers. It is defined as follows:

```
effect Pure (a:Type) (pre:Type) (post: a -> Type) =
       PURE a (fun (p:PurePost a) -> pre /\ forall (x:a). post x ==> p x)
              (fun (p:PurePost a) -> forall (x:a). pre /\ post x ==> p x)
```

That is `Pure a pre post` is a computation which when `pre` is true
produces a result `v:a` such that `post v` is true.

The `Tot` effect is defined below:

```
effect Tot (a:Type) =
       PURE a (fun (p:PurePost a) -> forall (x:a). p x)
              (fun (p:PurePost a) -> forall (x:a). p x)
```

This means that a computation type `Tot a` only reveals that the
computation always terminates with an `a`-typed result.

### From predicate transformers to pre- and post-conditions

We have just seen how the definition of `Pure a pre post` unfolds into
the `PURE` effect. It is also possible to go in the other direction,
turning a specification written in the `PURE a wp wlp` style into a
`Pure a pre post`. However, whereas F\* will always automatically
unfold the definition of `Pure` in terms of `PURE` as needed, it will
not automatically transform the more primitive `PURE` effect into the
derived form `Pure`. Instead, one uses an explicit coercion for this
purpose, with the signature shown below.

```
type as_requires (#a:Type) (wp:PureWP a)  = wp (fun x -> True)
type as_ensures  (#a:Type) (wlp:PureWP a) (x:a) = ~ (wlp (fun y -> ~(y=x)))
assume val as_Pure: #a:Type -> #b:(a -> Type)
          -> #wp:(x:a -> PureWP (b x))
          -> #wlp:(x:a -> PureWP (b x))
          -> =f:(x:a -> PURE (b x) (wp x) (wlp x))
          -> x:a -> Pure (b x) (as_requires (wp x))
                               (as_ensures (wlp x))
```

~Remark

 The second last argument to `as_Pure` is named `f` and is tagged with
 an equality constraint, written by preceding the bound variable name
 with the equality symbol, i.e., `=f`. Given an application
 `as_Pure g`, the equality constraint on the `f` argument of `as_Pure`
 instructs F\*'s type inference engine to unify the type of `g` with
 the expected type of `f`. Without this constraint, by default, F\*
 will try to prove that the type of `g` is a subtype of the expected
 type of `f`. In cases like this, where an argument mentions several
 implicit arguments that need to be inferred (`a, b, wp, wlp`, in this
 case), the equality constraint produces better inference resutls.

~

One way to understand this type is as follows: `as_Pure f` coerces the
type of `f` which has a `PURE (b x) wp wlp` effect to an equivalent
function type written in terms of `Pure`.  The pre-condition of the
resulting function type is easily computed from the `wp`, using
`as_requires wp`, which is just the weakest pre-condition of the
trivial post-condition.

Computing the post-condition is a bit more subtle, and is accomplished
with the `as_ensures wlp` function. Perhaps the easiest way to
understand it is by studying the roundtrip transformation of `PURE` to
`Pure` and back to `PURE`. The key step below is in the transformation
from (b) to (c), where we see that by ensuring
`~wlp (fun y -> y <> x)`, we make use precisely of the Identity 1
from the previous section. Given only a `wp` without a `wlp`, we would be
stuck not being able to construct `as_ensures`.

```
(a) Pure t (as_requires wp)
           (as_ensures wlp)

= (definition)

(b) PURE t (fun post -> wp (fun x -> True) /\ forall y. ~(wlp (fun y' -> y<>y')) ==> post y)
           (fun post -> forall y. wp (fun x -> True) /\  ~(wlp (fun y’ -> y<>y')) ==> post y)

= (unfolding ==> and double negation)

(c) PURE t (fun post -> wp (fun x -> True) /\ forall y.  wlp (fun y' -> y<>y’) \/ post y)
           (fun post -> forall y. not (wp (fun x -> True)) \/ wlp (fun y’ -> y<>y’) \/ post y)

= (folding ==>)

(d) PURE t (fun post -> wp (fun x -> True) /\ forall y.  wlp (fun y’ -> y<>y’) \/ post y)
           (fun post -> forall y. wp (fun x -> True) ==> (wlp (fun y’ -> y<>y’) \/ post y))

= (rearranging quantifier)

(e) PURE t (fun post -> wp (fun x -> True) /\ forall y.  wlp (fun y’ -> y<>y’) \/ post y)
           (fun post -> wp (fun x -> True) ==> forall y. (wlp (fun y’ -> y<>y’) \/ post y))

= (identity 1)

(f) PURE t (fun post -> wp (fun x -> True) /\ wlp (fun y’ -> post y’))
           (fun post -> wp (fun x -> True) ==> wlp (fun y’ -> post y’))

<: (strengthening wlp, eta reduction)

(g) PURE t (fun post -> wp (fun x -> True) /\ wlp post)
            wlp

= (identity 2, eta)

(h) PURE t wp wlp
```

Here are a few small examples using this coercion to move from `PURE`
to `Pure`.

```
val f : x:int -> PURE int (fun 'p -> x > 0 /\ 'p (x + 1)) (fun 'p -> x > 0 ==> 'p (x + 1))
let f x = assert (x > 0); x + 1

val h : #req:(int -> Type)
     -> #ens:(int -> int -> Type)
     -> =f:(x:int -> Pure int (req x) (ens x))
     -> y:int -> Pure int (req y) (ens y)
let h f x = f x

val g : x:int -> Pure int (x > 0) (fun y -> y == x + 1)
let g = h (as_Pure f)
```

~Exercise

Work out the roundtrip unfolding a `Pure t pre post` into a `PURE`
effect and then back to a `Pure` using the `as_Pure` coercion. Prove
that after this round trip, the resulting type is logically equivalent
to the type you started with.

~~ Answer
```
Pure t p q

= (definition)

PURE t wp wlp
  where wp  = fun post -> p /\ forall (y:t). q y ==> post y
    and wlp = fun post -> forall (y:t). p /\ q y ==> post y

<:  (definition)

  Pure t (p /\ forall (y:t). q y ==> True)
         (fun y -> not (forall (z:t). p /\ q z ==> (y<>z)))

=  (simplification/de Morgan)

Pure t (p)
       (fun y -> exists (z:t). p /\ q z /\ y=z)

= (replacing existential by equality)

   Pure t p
          (fun y -> p /\ q y)

<: (weakening post-condition, eta)

   Pure t p q
```
~~
~


## The `STATE` effect

Stateful programs operate on an input heap producing a result and an
output heap. The computation type `STATE t wp wlp` describes such a
computation, where `wp, wlp : StateWP t` has the signature below.

```
kind StatePost t = t -> heap -> Type
kind StatePre    = heap -> Type
kind StateWP t   = StatePost t -> StatePre
```

In other words, WPs and WLPs for stateful programs transform stateful
post-conditions (relating the t-typed result of a computation to the
final heap) into a pre-condition, a predicate on the input heap.

The type `heap` is axiomatized in `lib/heap.fst` and is one model of
the primitive heap provided by the F\* runtime system. Specifically,
we have functions to select, update, and test the presence of a
reference in a heap.

```
module Heap
assume type heap
assume val sel : #a:Type -> heap -> ref a -> Tot a
assume val upd : #a:Type -> heap -> ref a -> a -> Tot heap
assume val contains : #a:Type -> heap -> ref a -> a -> Tot bool
```

These functions are interpreted using standard axioms, which allows
the SMT solver to reason about heaps, for instance:

```
assume SelUpd1:       forall (a:Type) (h:heap) (r:ref a) (v:a).
                      {:pattern (sel (upd h r v) r)}
                      sel (upd h r v) r = v

assume SelUpd2:       forall (a:Type) (b:Type) (h:heap) (k1:ref a) (k2:ref b) (v:b).
                      {:pattern (sel (upd h k2 v) k1)}
                      k2=!=k1 ==> sel (upd h k2 v) k1 = sel h k1
```

The `Heap` library axiomatizes several other functions---the
interested reader refer to `lib/heap.fst` for more details.

~Remark
Note, although `sel` is marked as a total function, the axioms
underspecify its behavior, e.g., `sel h r` has no further
interpretation unless `h` can be proven to be an `upd`.

Also note the use of the `{:pattern ...}` form in the axioms above.
This provides the SMT solver with a trigger for the quantifiers, in
effect orienting the equalities in `SelUpd1` and `SelUpd2` as
left-to-right rewritings.
~

The functions `sel` and `upd` provide a logical theory of heaps. At
the programmatic level, we require stateful operations to allocate,
read and write references in the current heap of the program. The
signatures of these stateful primitives are provided in `lib/st.fst`,
as illustrated (in slightly simplified form) below.

Let's start with the signature of `read`:

```
assume val read: #a:Type -> r:ref a -> STATE a (wp_read r) (wp_read r)
where wp_read r = fun (post:StatePost a) (h0:heap) ->  post (sel h0 r) h0
```

This says that `read r` returns a result `v:a` when `r:ref a`;
and, to prove for any post-condition `post:StatePost a` relating the
`v` to the resulting heap, it suffices to prove `post (sel h0 r) h0`
when `read r` is run in the initial heap `h0`.

Next, here's the signature of `write`:

```
assume val write: #a:Type -> r:ref a -> v:a -> STATE unit (wp_write r) (wp_write r)
where wp_write r = fun (post:StatePost a) (h0:heap) -> post () (upd h0 r v)
```

This says that `write r v` returns a a `unit`-typed result when
`r:ref a` and `v:a`; and, to prove any post-condition `post:StatePost a`
relating the `()` to the resulting heap, it suffices to prove
`post () (upd h0 r v)` when `write r v` is run in the initial heap `h0`.

~Remark
F\* provides support for user-defined custom operators. To allow you to
write `!r` for `read r` and `r := v` instead of `ST.write r v`, we define
```
let op_Bang x = ST.read x
```
and
```
let op_Colon_Equals x v = ST.write x v
```
~

As with the `PureWP`, the predicate transformers `StateWP t` form a
monad, as shown by the combinators below.

```
type return_STATE (#a:Type) (v:a) = fun (post:StatePost a) (h0:heap) -> post v h0

type bind_STATE (#a:Type) (wp1:StateWP a) (wp2:a -> StateWP b)
     = fun (post:StatePost b) (h0:heap) -> wp1 (fun (x:a) -> wp2 x post) h0
```

### The `ST` effect

`ST` is to `STATE` what `Pure` is to `PURE`: it provides a way to
write stateful specifications using pre- and post-conditions instead
of predicate transformers. It is defined as shown below (in
`lib/st.fst`):

```
effect ST (a:Type) (pre:StatePre) (post: (heap -> StatePost a)) = STATE a
  (fun (p:StatePost a) (h:heap) ->
     pre h /\ (forall a h1. (pre h /\ post h a h1) ==> p a h1)) (* WP *)
  (fun (p:StatePost a) (h:heap) ->
     (forall a h1. (pre h /\ post h a h1) ==> p a h1))          (* WLP *)
```

As before, we can also define a coercion to move to `ST` from `STATE`.


```
type as_requires (#a:Type) (wp:STWP_h heap a)  = wp (fun x h -> True)
type as_ensures  (#a:Type) (wlp:STWP_h heap a) (h0:heap) (x:a) (h1:heap)
  = ~ (wlp (fun y h1' -> y<>x \/ h1<>h1') h0)
val as_ST: #a:Type -> #b:(a -> Type)
          -> #wp:(x:a -> STWP_h heap (b x))
          -> #wlp:(x:a -> STWP_h heap (b x))
          -> =f:(x:a -> STATE (b x) (wp x) (wlp x))
          -> x:a -> ST (b x) (as_requires (wp x))
                             (as_ensures (wlp x))
```

And here's a small program that uses this coercion.

```
let f x = !x * !x

val h : #req:(ref int -> heap -> Type)
     -> #ens:(ref int -> heap -> int -> heap -> Type)
     -> =f:(x:ref int -> ST int (req x) (ens x))
     -> y:ref int -> ST int (req y) (ens y)
let h f x = f x

val g : x:ref int -> ST int (fun h -> True) (fun h0 y h1 -> h0=h1 /\ y >= 0)
let g = h (as_ST f)
```

### The `St` effect

We define another abbreviation on top of `ST` for stateful programs with
trivial pre- and post-conditions.

```
  effect St (a:Type) = ST a (fun h -> True) (fun _ _ _ -> True)
```

## Lifting effects

When programming with multiple effects, you can instruct F\* to
automatically infer a specification for your program with a predicate
transformer that captures the semantics of all the effects you
use. The way this works is that F\* computes the least effect for each
sub-term of your program, and then lifts the specification of each
sub-term into some larger effect, as may be needed by the context.

For example, say you write:

```
let y = !x in y + 1
```

The sub-term `!x` has the `STATE` effect; whereas the sub-term `y+1`
is `PURE`. Since the whole term has at least `STATE` effect, we'd like
to lift the pure sub-computation to `STATE`. To do this, you can
specify that `PURE` is a sub-effect of `STATE`, as follows (adapted
from `lib/prims.fst`):

```
sub_effect
  PURE   ~> STATE = fun (a:Type) (wp:PureWP a) (p:StatePost a) (h:heap) ->
                    wp (fun a -> p a h)
```

This says that in order to lift a `PURE` compuataion to `STATE`, we
lift its `wp:PureWP a` (equivalently for its `wlp`) to a `StateWP a`
that says that that pure computation leaves the state unmodified.

Note that the type of `PURE ~> STATE` is
`(a:Type) -> PureWP a -> StatePost a -> heap -> Type` which corresponds
to `(a:Type) -> PureWP a -> StateWP a` since:
```
kind StateWP a   = StatePost a -> StatePre
kind StatePre    = heap -> Type
```

## Indexed computation types

Finally, as mentioned earlier, in its full form a computation type has
the shape `M t_1..t_n t wp wlp`, where `t_1..t_n` are some user-chosen
indices to the effect constructor `M`.

This is convenient in that it allows effects to be defined
parametrically, and specific effects derived just by instantiation.

For example, the `STATE` effect is actually defined as an instance of
a more general parameterized effect `STATE_h (mem:Type)`, which is
parametric in the type of the memory used by the state monad.

Specifically, we have in `lib/prims.fst`

```
new_effect STATE = STATE_h heap
```

However, as we will see in subsequent sections, it is often convenient
to define other variants of the state monad using different memory
structures.

# Verifying Stateful Programs

In the previous chapter, we saw how F\*'s `ST` monad was specified. We
now look at several programs illustrating its use. If you skipped the
previous chapter, you should be ok---we'll explain what's needed about
the `ST` monad as we go along, although, eventually, you'll probably
want to refer to the previous chapter for more details.

## Stateful access control

We'll start with a simple example, based on the access control example
from [#sec-access-control]. A restriction of that example was that the
access control policy was fixed by the two functions `canWrite` and
`canRead`. What if we want to administer access rights using an access
control list (ACL)? Here's one simple way to model it---of course, a
full implementation of stateful access control would have to pay
attention to many more details.

The main idea is to maintain a reference that holds the current access
control list. In order to access a resource, we need to prove that the
current state contains the appropriate permission.

Here's how it goes:

```
[INCLUDE=code/exercises/ex10a-acls-variant.fst]
```

~Exercise
Write down some types for `grant` and `revoke` that are sufficiently
precise to allow the program to continue to type-check.

~~ ExerciseFragment {exname=ex10a-acls}
val grant : e:entry -> ST unit (requires (fun h -> True))
                               (ensures (fun h x h' -> True))
let grant e = ST.write acls (e::ST.read acls)

val revoke: e:entry -> ST unit (requires (fun h -> True))
                               (ensures (fun h x h' -> True))
let revoke e =
  let db = List.filterT (fun e' -> e<>e') (ST.read acls) in
  ST.write acls db
~~

~~Answer
~~~ SolutionFragment {exname=ex10a-acls}
val grant : e:entry -> ST unit (requires (fun h -> True))
                               (ensures (fun h x h' -> sel h' acls = e::sel h acls))
let grant e = ST.write acls (e::ST.read acls)

val revoke: e:entry -> ST unit (requires (fun h -> True))
                               (ensures (fun h x h' -> not(List.mem e (sel h' acls))))
let revoke e =
  let db = List.filter (fun e' -> e<>e') (ST.read acls) in
  ST.write acls db
~~~
~~
~

## Reasoning about (anti-)aliased heap structures

A central problem in reasoning about heap-manipulating programs has to do
with reasoning about updates to references in the presence of aliasing. In general,
any two references (with compatible types) can alias each other (i.e, they may refer
to the same piece of memory), so updating one can also change the contents of the other.
In this section, we'll look at two small but representative samples that illustrate
how this form of reasoning can be done in F\*.

### Dynamic frames

For our first example, we define the type of a 2-dimensional
mutable point. The refinement on `y` ensures that the references
used to store each coordinate are distinct.

```
type point =
  | Point : x:ref int -> y:ref int{y<>x} -> point
```

Allocating a new point is straightforward:

```
let new_point x y =
  let x = ST.alloc x in
  let y = ST.alloc y in
  Point x y
```

As is moving a point by a unit along the `x`-axis.
```
let shift_x p = Point.x p := !(Point.x p) + 1
```

Now, things get a bit more interesting. Let's say we have
a pair of points, `p1` and `p2`, we want to shift `p1`, and
reason that `p2` is unchanged. For example, we'd like
to identify some conditions that are sufficient to prove that
the assertion in the program below always succeeds.

```
let shift_p1 (p1:point) (p2:point) =
    let p2_0 = !(Point.x p2), !(Point.y p2)  in //p2 is initially p2_0
    shift_x p1;
    let p2_1 = !(Point.x p2), !(Point.y p2) in
    assert (p2_0 = p2_1)                        //p2 is unchanged
```

If you give this program (reproduced in its entirety below) to F\*, it
will report no errors. This may surprise you: after all, if you call
`shift_p1 p p` the assertion will indeed fail. What's going on here is that
for functions in the `ST` effect, F\* infers a most precise type for it,
and if the programmer did not write down any other specification, this
precise inferred type is what F\* will use. This means that without an
annotation on `shift_p1`, F\* does not check that the assertion will succeed
on every invocation of `shift_p1`; instead, using the inferred type it will
aim to prove that the assertion will succeed whenever the function is
called. Let's try:

```
val test0: unit -> St unit
let test0 () =
  let x = new_point 0 0 in
  shift_p1 x x
```

Here, we wrote a specification for `test0`, asking it to have trivial
pre-condition. When we ask F\* to check this, it complains at the call to
`shift_p1 x x`, saying that the assertion failed.

If we try calling `shift_p1` with two distinct points, as below, then we
can prove that the assertion succeeds.

```
val test1: unit -> St unit
let test1 () =
  let x = new_point 0 0 in
  let y = new_point 0 0
  shift_p1 x y
```

In simple code like our example above, it is a reasonable trade-off to let F\* infer
the most precise type of a function, and to have it check later, at each call site, that
the those calls are safe.

As you write larger programs, it's a good idea to write down the types
you expect, at least for tricky top-level functions. To see what these
types look like for stateful programs, let's decorate each of the
top-level functions in our example with the types---for these tiny
functions, the types can often be larger than the code itself; but this
is just an exercise. Typically, one wouldn't write down the types of such
simple functions.

### A type for `shift_x` and the `Heap.modifies` predicate

Let's start with `shift_x`, since it is the simplest:

Here's one very precise type for it:

```
val shift_x : p:point -> ST unit
  (requires (fun h -> True))
  (ensures (fun h0 _ h1 -> h1=upd h0 (Point.x p) (sel h0 (Point.x p) + 1)))
```

Another, less precise but more idiomatic type for it is:

```
val shift_x : p:point -> ST unit
  (requires (fun h -> True))
  (ensures (fun h0 _ h1 -> modifies (only (Point.x p)) h0 h1))
```

Informally, `ensures`-clause above says that the heap after calling this
function (`h1`) differs from the initial heap `h0` only at `Point.x` (and
possibly some newly allocated locations). Let's look at it in more detail.

The predicate `modifies` is defined in the module `Heap`
(`lib/heap.fst`). First, let's look at its signature, which says that it
relates a `set aref` to a pair of heaps. The type `aref` is the type of a
reference, but with the type of referent abstracted. As such, the first
argument to `modifies` is a set of heterogenously typed references.

```
  type aref =
    | Ref : #a:Type -> ref a -> aref
  let only x = Set.singleton (Ref x)
  type modifies : set aref -> heap -> heap -> Type
```

The definition of `modifies` follows:

```
type modifies mods h0 h1 =
  Heap.equal h1 (Heap.concat h1 (Heap.restrict (Set.complement mods) h0))

```
**Heap.equal**: `Heap.equal` is an equivalence relation on `heap` capturing the notion of
_extensional equality_; i.e., two heaps are extensionally equal if they map each
reference to the same value.

**Heap.concat**: Each reference `r` in the heap `concat h h'` contains a value that is the
same as in `h`, except if the `r` is in `h'`, in which case it's value is
whatever value `h'` contains at `r`. More formally:

```
   sel r (concat h h')
   = if contains h' r then sel h' r else sel h r
```

**Heap.restrict** The function `restrict s h` provides a way to shrink
the domain of the heap `h` to be at most `s`. Specifically:

```
  contains (restrict s h) r = Set.mem (Ref r) s && contains h r
```

Altogether, the definition of `modifies` says that for every reference `r`,
if `r` is not in the set `mods` and `r` if the heap `h0` contains `r`,
then `sel h1 r = sel h0 r`, i.e., it hasn't changed. Otherwise,
`sel h1 r = sel h1 r`---meaning we know nothing else about it.

~Remark
We define the following infix operators to build sets of heterogenous references.

```
let op_Hat_Plus_Plus (#a:Type) (r:ref a) (s:set aref) =
    Set.union (Set.singleton (Ref r)) s

let op_Plus_Plus_Hat (#a:Type) (s:set aref) (r:ref a) =
    Set.union s (Set.singleton (Ref r))

let op_Hat_Plus_Hat (#a:Type) (#b:Type) (r1:ref a) (r2:ref b) =
    Set.union (Set.singleton (Ref r1)) (Set.singleton (Ref r2))
```
~

### A type for `new_point` and freshness of references

Here's a precise type for `new_point`, with its definition reproduced
for convenience.

```
val new_point: x:int -> y:int -> ST point
  (requires (fun h -> True))
  (ensures (fun h0 p h1 ->
                modifies Set.empty h0 h1
                /\ fresh (Point.x p ^+^ Point.y p) h0 h1
                /\ Heap.sel h1 (Point.x p) = x
                /\ Heap.sel h1 (Point.y p) = y))
let new_point x y =
  let x = ST.alloc x in
  let y = ST.alloc y in
  Point x y
```

The `modifies` clause says the function modifies no existing
reference---that's easy to see, it only allocates new references.

In the body of the definition, we build `Point x y` and the type of
`Point` requires us to prove that `x <> y`. The only way to prove that is
if we know that `ref` returns a distinct reference each time, i.e., we
need freshness.

The type of `ST.alloc`
gives us the freshness we need to prove that `x <> y`. The type
below says that the returned reference does not exists in the initial heap
and does exist in the final heap (initialized appropriately).

```
val alloc:  #a:Type -> init:a -> ST (ref a)
    (requires (fun h -> True))
    (ensures (fun h0 r h1 -> fresh (only r) h0 h1 /\ h1==upd h0 r init))

type fresh (refs:set aref) (h0:heap) (h1:heap) =
  forall (a:Type) (r:ref a). mem (Ref r) refs
                         ==> not(contains h0 a) /\ contains h1 a
```


Coming back to the type of `new_point`: By stating that the new heap
contains both `Point.x` and `Point.y`, we provide the caller with enough
information to prove that any references that it might allocate
subsequently will be different from the references in the newly allocated
point. For example, the assertion in the code below succeeds, only
because `new_point` guarantees that the heap prior to the allocation of
`z` contains `Point.x p`; and `ST.alloc` guarantees that `z` is different
from any reference that exists in the prior heap. Carrying
`Heap.contains` predicates in specifications is important for this
reason.


```
let p = new_point () in
let z = ST.alloc 0 in
assert (Point.x p <> z)
```

On the other hand, since the `ST` library we are working with provides no
ability to deallocate a reference (other versions of it do; see, for
example, `lib/stperm.fst`), we know that if we have a value `v:ref t`,
that the current heap must contain it. Capturing this invariant, the `ST`
library also provides the following primitive (whose implementation is a
noop).

```
val recall: #a:Type -> r:ref a -> ST unit
  (requires (fun h -> True))
  (ensures (fun h0 _ h1 -> h0=h1 /\ Heap.contains h1 r))
```

Using this, we can write the following code.

```
val f : ref int -> St unit
let f (x:ref int) =
  recall x;         //gives us that the initial heap contains x, for free
  let y = ST.alloc 0 in
  assert (y <> x)
```

As a matter of style, we prefer to keep the use of `recall` to a minimum,
and instead carry `Heap.contains` predicates in our specifications, as
much as possible.

### A type for `shift_p1`

Now, we have all the machinery we need to give `shift_p1` a sufficiently
strong type to prove that its assertion will never fail (if its pre-condition is met).

```
val shift_p1: p1:point
           -> p2:point{   Point.x p2 <> Point.x p1
                       /\ Point.y p2 <> Point.x p1 }
           -> ST unit
    (requires (fun h -> True))
    (ensures (fun h0 _ h1 -> modifies (only (Point.x p1)) h0 h1))
```

In order to prove that the assignment to `Point.x p1` did not change
`p2`, we need to know that `Point.x p1` does not alias either component
of `p2`. In general, if `p1` can change arbitrarily, we also need the
other two conjuncts, i.e., we will need that the references of `p1` and `p2`
are pairwise distinct.

~Remark
A note on style: we could have placed the refinement on `p2` within the
requires clause. However, since the refinement is independent of the
state, we prefer to write it in a manner that makes its state independence
explicit.
~

~Exercise
Change `shift_x` to the function `shift` below that moves both the `x` and `y` components
of its argument by some amount. Prove that calling this function in
`shift_p1` does not change `p2`.

~~ CodeFragment {filename=exercises/ex10-shift.fst name=ex10b-shift}
let shift p = Point.x p := 17; Point.y p := 18
~~

~~Answer
~~~ CodeFragment {filename=solutions/ex10-shift.fst name=so10b-shift}
let shift p = Point.x p := 17; Point.y p := 18
~~~
~~
~


# Lightweight framing with hyper-heaps

The style of the previous section is quite general. But, as programs scale up,
specifying and reasoning about anti-aliasing can get to be quite tedious. In this chapter,
we look at an alternative way of proving stateful programs correct by making use of
a more structured representation of memory that we call a "HyperHeap". First, we illustrate
the problem of scaling up the approach of the previous chapter to even slightly larger examples

```
  type a = b
  ```

## Flying robots

![johnnysokko]

Let's have some fun with flying robots. Maybe you've seen this classic Japanese
TV series from the 60s. <https://en.wikipedia.org/wiki/Giant_Robo_(tokusatsu)>. Let's build
a tiny model of this flying robot.

Our `bot` has a 3d-point representing its position; and two arms, both in polar coordinates.

```
  type bot = {
    pos:point;
    left:arm;
    right:arm
  }
  and point = {
    x:ref int;
    y:ref int;
    z:ref int;
  }
  and arm = {
    polar:ref int;
    azim:ref int
  }
```

Our bot has an invariant: whenever it is flying, it has its arms up.

![flying]

We can write a function to make our robot fly, which sets its arms up and then
shoots the robot into the sky.

```
  let fly b =
    b.left.polar := 0;
    b.right.polar := 0;
    b.z := 100
  ```

Now, we'd like to prove properties like the following:

```
  //initially, in h0: b1 not flying, b2 not flying
      fly b1
  //in h1: b1 flying, b2 not flying
  ```

To prove this property, and to prove that the bot's invariant is
maintained, we need many anti-aliasing invariants, including the
following (stated informally).

```
forall r1, r2. r1 in refs_in b1
              /\ r2 in refs_in b2 ==> r1 <> r2
refs in b.left.arm `disjoint` refs in b.pos
refs in b.right.arm `disjoint` refs in b.pos
refs in b.left.arm `disjoint` refs in b.right.arm
```

As you can see, what started out as a bit of fun programming is now a
painful exercise in managing anti-aliasing invariants. Worse, even if we
state all these invariants, proving that they are preserved involves
reasoning about a quadratic number of inequalities between the all the
references in each robot, as well as a further quadratic inequalities
among the references of each bot.

F\*'s effect mechanism provides an alternative to this tedium. Instead of
working with the primitive `ST` effect (and its flat model of memory via
the `heap` type) that we have been working with so far, we can define
easily define a different, more structured view of memory as a new effect.
One such alternative is the HyperHeap, a model of memory which provides a
convenient built-in notion of disjoint sets of references.

[johnnysokko]: johnnysokko.jpg "Johnny Sokko" { width=300px }
[flying]: flying.gif "Flying Bot" { width=200px }
[heap]: heap.jpg "A flat heap" {width=300px}
[hyperheap]: hyperheap.jpg "A hyper-heap" {width=500px}

## Hyper-heaps

So far, we have been working with the `heap` type, a flat, typed-map from
references to their contents. The `ref` type is abstract---it has no structure
and only supports equality operations. Conceptually, it looks like this:

![heap]

A hyper-heap provides organizes the heap into many disjoint fragments, or
regions. Each region is collectively addressed by a _region identifier_,
and these identifiers are organized in a tree-shaped hierarchy. Each
region is itself a map from typed references to values, just like our
heaps from before. The picture below depicts the structure.

![hyperheap]

At the top-level we have regions `R0 ... Rn`, each associated with a
fragment of heap references. Region identifiers `R0.0 ... R0.m` are
within the hierarchy rooted at `R0`; each has a set of references distinct from
all other regions (including its parent `R0`); and so on.

The `HyperHeap` module in F\*'s standard library defines this structure,
a type `rid` for region ids, and a type `rref (r:rid) (a:Type)`, which is
the type of a reference in region `r` that points to an `a`-typed value.
We prove that values of type `rref r a` are in an injection with values
of type `ref a`---meaning that hyper-heaps are in 1-1 correspondence with
the underlying heap, except, as we will see, the additional structure
provided helps with stating and proving memory invariants.

The module `HyperHeap` defines (see `lib/hyperheap.fsi`, for its abstract
specification):

```
type t = Map.t rid heap
new_effect STATE = STATE_h t
effect ST (a:Type) (pre:t -> Type) (post:t -> a -> t -> Type) =
       STATE a (fun 'p m0 -> pre m0 /\ (forall x m1. post m0 x m1 ==> 'p x m1))
               (fun 'p m0 ->  (forall x m1. pre m0 /\ post m0 x m1 ==> 'p x m1))
```

That is `HyperHeap.STATE` and `HyperHeap.ST` are just like the `STATE`
and `ST` we've been working with, except that instead of the type of
memory being a flat `heap`, the memory has type `HyperHeap.t`, a map from
region ids `rid` to `heaps`.

### The type of region identifiers, `rid`

The type `rid` is abstract to clients, with a few operations on it
revealing its hierarchical structure. Specifically, we have three functions:

```
type rid
val root : rid
val includes : rid -> rid -> Tot bool
val extends  : rid -> rid -> Tot bool
let disjoint i j = not (includes i j) && not (includes j i)
```

One way to think of `rid` is as a `list int`, where `includes i j` if and
only if `i` is a prefix of `j`; and `extends i j` is true if `i = _::j`.
However, while this may provide you with some intuition, formally, the
only properties that these functions are known to satisfy are revealed by
the following lemmas:

```
val lemma_includes_refl: i:rid
-> Lemma (requires (True))
         (ensures (includes i i))
         [SMTPat (includes i i)]

val lemma_disjoint_includes: i:rid -> j:rid -> k:rid
-> Lemma (requires (disjoint i j /\ includes j k))
         (ensures (disjoint i k))
         [SMTPat (disjoint i j);
          SMTPat (includes j k)]

val lemma_extends_includes: i:rid -> j:rid
-> Lemma (requires (extends j i))
         (ensures (includes i j))
         [SMTPat (extends j i)]

val lemma_extends_disjoint: i:rid -> j:rid -> k:rid
-> Lemma (requires (extends j i /\ extends k i /\ j<>k))
         (ensures (disjoint j k))
         [SMTPat (extends j i);
          SMTPat (extends k i)]
```

### The type of region-indexed references: `rref`

Next, we have a type `rref` for region-indexed
references, as a funtion `as_ref` that coerces an `rref` to its
underlying heap reference.

~ Remark
The functions `as_ref` and `ref_as_rref` have effect `GTot`, indicating
that they are **ghostly** total functions. A subsequent chapter will
describe ghost effects in more detail. For now, it suffices to know that
computations with effect `GTot` can only be used in specifications.
Concrete executable programs cannot use `GTot`. In this case, the `GTot`
effect is used to ensure that client programs of `HyperHeap` cannot break
the abstraction of the `rref` type, except in their specifications.

~

```
  type rref : rid -> Type -> Type
  val as_ref      : #a:Type -> #id:rid -> r:rref id a -> GTot (ref a)
  val ref_as_rref : #a:Type -> i:rid -> r:ref a -> GTot (rref i a)
  val lemma_as_ref_inj: #a:Type -> #i:rid -> r:rref i a
      -> Lemma (requires (True))
               (ensures ((ref_as_rref i (as_ref r) = r)))
         [SMTPat (as_ref r)]
```

The functions `Heap.sel` and `Heap.upd` are adapted to work with
hyper-heaps instead; in effect, we select first the region `i`
corresponding to `rref i a` and then perform the select/update within the
heap within that region. An important point to note is that although the
`rid` type is structured hierarchically, the map of all regions is itself
flat. Thus, selecting the region corresponding to `i` is constant time
operation (rather than requiring a tree traversal). As we will see below,
this is crucial for good automation in proofs.

```
let sel (#a:Type) (#i:rid) (m:t) (r:rref i a) = Heap.sel (Map.sel m i) (as_ref r)
let upd (#a:Type) (#i:rid) (m:t) (r:rref i a) (v:a)
  = Map.upd m i (Heap.upd (Map.sel m i) (as_ref r) v)
```
### Stateful operations on regions and references

**Creating a new region** `HyperHeap` also provides four main stateful functions. The
first of these, `new_region r0`, allocates a new, empty region rooted at `r0`

```
val new_region: r0:rid -> ST rid
      (requires (fun m -> True))
      (ensures (fun (m0:t) (r1:rid) (m1:t) ->
                           extends r1 r0
                        /\ fresh_region r1 m0 m1
                        /\ m1=Map.upd m0 r1 Heap.emp))
```

**Allocating a reference in a region** The function `ralloc r v` allocates a new reference
 in region `r` and initializes its contents to `v`.

```
val ralloc: #a:Type -> i:rid -> init:a -> ST (rref i a)
    (requires (fun m -> True))
    (ensures (fun m0 x m1 ->
                    Let (Map.sel m0 i) (fun region_i ->
                    not (Heap.contains region_i (as_ref x))
                    /\ m1=Map.upd m0 i (Heap.upd region_i (as_ref x) init))))
```

**Reading and writing references** These next two operations are written `!r`
and `r := v`, for dereference and assignment of `rref`'s, respectively.

```
val op_Bang: #a:Type -> #i:rid -> r:rref i a -> ST a
  (requires (fun m -> True))
  (ensures (fun m0 x m1 -> m1=m0 /\ x=Heap.sel (Map.sel m0 i) (as_ref r)))

val op_Colon_Equals: #a:Type -> #i:rid -> r:rref i a -> v:a -> ST unit
  (requires (fun m -> True))
  (ensures (fun m0 _u m1 -> m1=Map.upd m0 i (Heap.upd (Map.sel m0 i) (as_ref r) v)))
```

### Framing conditions for hyper-heaps: `modifies` revised

Finally, we redefine `modifies` clauses to work with hyper-heaps instead
of heaps. Crucially, given a region ids `r1, ..., rn`, we intend to write
`modifies (r1 ^++ ... ++^ rn) h0 h1` to mean that `h1` may differ from
`h0` in all regions _rooted at some region_ in the set `{r1, ..., rn}`
(and, as before, any other regions that are newly allocated in `h1`). As
we will see, generalizing modifies clauses to work with hierarchical
region names is a crucial feature, both for compactness of specifications
and for better automation.


```
type modifies (s:Set.set rid) (m0:t) (m1:t) =
  Map.Equal m1 (Map.concat m1 (Map.restrict (Set.complement (mod_set s)) m0))

where
val mod_set : Set.set rid -> GTot (Set.set rid)
and forall (x:rid) (s:Set.set rid).
           Set.mem x (mod_set s) <==> (exists (y:rid). Set.mem y s /\ includes y x)
```

~Remark
The interpretation of `Map.restrict, Map.concat` and `Map.Equal` is
analogous to the counterparts for `Heap` discussed in the previous
section.

The definition of `mod_set s` is non-constructive, since deciding
`Set.mem x (mod_set s)` requires finding a witness in `s`, and element
`y` of `s`, such that `includes y x`. As such, we mark it as a ghost
function with the `GTot` effect.
~

## Robot, fly!

We now look at the use of hyper-heaps to solve our problem of
programming our robots.

The main idea is to define our data structures in a way that distinct
components of the robot are allocated in distinct regions, thereby
maintaining an invariant that the components do not interfere. For
example, by allocating the left arm and the right arm of the robot in
distinct regions, we know that the arms do not alias each other---moving
one arm does not disturb the other.

Here's how it goes:

Each type carries an extra implicit parameter, recording the region in
which its mutable references reside. Within a region, we get no free
anti-aliasing properties---so, for those references, we write explicit
inequalities that say, for example, that the `x, y` and `z` fields of a
point are not aliased.

For the `bot` itself, we say that its components are allocated in
disjoint sub-regions of `r`, the region of the bot. Note that the
hierarchical region names allow us to state this conveniently. With just
a flat namespace of regions, we would had to have explicitly specified
the set of regions that are transitively allocated within a bot (possibly
breaking the abstraction of sub-objects, which would have to reveal how
many regions they used.)

```
module Robot
open Util
open Heap
open HyperHeap

type point =
  | Point : #r:rid
          -> x:rref r int
          -> y:rref r int
          -> z:rref r int{x<>y /\ y<>z /\ x<>z}
          -> point

type arm =
  | Arm : #r:rid
       -> polar:rref r int
       -> azim:rref r int{polar <> azim}
       -> arm

type bot =
  | Bot : #r:rid
       -> pos  :point{includes r (Point.r pos)}
       -> left :arm  {includes r (Arm.r left)}
       -> right:arm  {includes r (Arm.r right)
                        /\ disjoint (Point.r pos) (Arm.r left)
                        /\ disjoint (Point.r pos) (Arm.r right)
                        /\ disjoint (Arm.r left)  (Arm.r right)}
       -> bot
```

Next, we define our robot invariant: whenever it is flying, its arms are
up. Additionally, we state that all the regions of the bot are included
in the heap. This is a matter of taste: alternatively, we could have
omitted the `contains` predicates in our invariant, and resorted to
`ST.recall` (its analog for hyper-heaps), to prove that a region exists
whenever we need that property.

```
let flying (b:bot) (h:HyperHeap.t) =
    sel h (Point.z (Bot.pos b)) > 0

let arms_up (b:bot) (h:HyperHeap.t) =
    sel h (Arm.polar (Bot.right b)) = 0
    && sel h (Arm.polar (Bot.left b)) = 0

type robot_inv (b:bot) (h:HyperHeap.t) =
  Map.contains h (Bot.r b)
  /\ Map.contains h (Point.r (Bot.pos b))
  /\ Map.contains h (Arm.r (Bot.left b))
  /\ Map.contains h (Arm.r (Bot.right b))
  /\ (flying b h ==> arms_up b h)
```

Now, we come to the code that builds new points, arms, and robots. In
each case, the caller specifies `r0`, the region within which the object
is to be allocated. We create a new sub-region of `r0`, allocate the
object within in, prove that the region is fresh (meaning the initial
heap does not contain that region, while the final heap does), and that
the object is initialized as expected. Inthe case of `new_robot`, we also
prove that the the returned `bot` satisfies the robot invariant.


```
val new_point: r0:rid -> x:int -> y:int -> z:int -> ST point
    (requires (fun h0 -> True))
    (ensures (fun h0 p h1 ->
          modifies Set.empty h0 h1
          /\ extends (Point.r p) r0
          /\ fresh_region (Point.r p) h0 h1
          /\ sel h1 (Point.x p) = x
          /\ sel h1 (Point.y p) = y
          /\ sel h1 (Point.z p) = z))
let new_point r0 x y z=
  let r = new_region r0 in
  let x = ralloc r x in
  let y = ralloc r y in
  let z = ralloc r z in
  Point x y z

val new_arm: r0:rid -> ST arm
    (requires (fun h0 -> True))
    (ensures (fun h0 x h1 ->
          modifies Set.empty h0 h1
          /\ extends (Arm.r x) r0
          /\ fresh_region (Arm.r x) h0 h1))
let new_arm r0 =
  let r = new_region r0 in
  let p = ralloc r 0 in
  let a = ralloc r 0 in
  Arm p a

val new_robot: r0:rid -> ST bot (requires (fun h0 -> True))
                                (ensures (fun h0 x h1 ->
                                      modifies Set.empty h0 h1
                                      /\ extends (Bot.r x) r0
                                      /\ fresh_region (Bot.r x) h0 h1
                                      /\ robot_inv x h1))
let new_robot r0 =
  let r = new_region r0 in
  let p = new_point r 0 0 0 in
  let left = new_arm r in
  let right = new_arm r in
  Bot #r p left right
```

Next, we write our function `fly`, which sets the robots arms up, and
shoots it up to fly. As an illustration, we show that we can also modify
some other reference arbitrarily, and the anti-aliasing properties of our
invariant suffice to prove that this assignment does not mess with the
robot invariant.

```
val fly: b:bot -> ST unit
  (requires (robot_inv b))
  (ensures (fun h0 _u h1 ->
              modifies (only (Bot.r b)) h0 h1
              /\ robot_inv b h1
              /\ flying b h1))
let fly b =
  Arm.polar (Bot.left b)  := 0;
  Arm.polar (Bot.right b) := 0;
  Point.z (Bot.pos b)     := 100
  Arm.azim (Bot.right b)  := 17;
```

Finally, if we're given two robots, `b0` and `b1`, we know that they are
allocated in disjoint regions, and satisfy the robot invariant, then we
can fly one, not impact the invariant of the other; then fly the other,
and have both of them flying at the end.

```
val fly_robots: b0:bot
             -> b1:bot{disjoint (Bot.r b0) (Bot.r b1)}
             -> ST unit
    (requires (fun h -> robot_inv b0 h /\ robot_inv b1 h))
    (ensures (fun h0 x h1 ->
              modifies (Bot.r b0 ^+^ Bot.r b1) h0 h1
              /\ robot_inv b0 h1
              /\ robot_inv b1 h1
              /\ flying b0 h1
              /\ flying b1 h1))
let fly_robots b0 b1 =
  fly b0;
  fly b1
```


~Exercise
Extend this example by adding a function which takes a list of robots,
each in a region disjoint from all others, and fly all of them.

~~ CodeFragment {filename=exercises/robot2.fst name=ex11a-robot}
val fly_robot_army: ...
~~

~~Answer
~~~ CodeFragment {filename=solutions/robot2.fst name=so11a-robot}
val fly_robot_army:  #rs:Set.set rid
        -> bs:bots rs
        -> ST unit
           (requires (fun h -> (forall b.{:pattern (trigger b)}
                                            (trigger b /\ mem b bs ==> robot_inv b h))))
           (ensures  (fun h0 _u h1 ->
                          modifies rs h0 h1
                           /\ (forall b.{:pattern (trigger b)}
                                  (trigger b /\ mem b bs ==> robot_inv b h1 /\ flying b h1))))
~~~
~~
~


## Why hyper-heaps work

The style of dynamic frames and explicit inequalities between objects is
not incompatible with hyper-heaps: as we've also seen, within a region,
we resort to pairwise inequalities, as usual. However, using hyper-heaps
where possible, as we've just seen, makes specifications much more
concise. As it turns out, they also make verifying programs much more
efficient. On some benchmarks, we've noticed a speedup in verification
time of more than a factor of `20x` when using hyper-heaps for
disjointness invariants. In this section, we look a bit more closely at
what's happening under the covers and why hyper-heaps help.

First, without hyper heaps, consider a computation `f ()` run in a heap
`h0` and producing a heap `h1` related by `modifies {x1,...,xn} h0 h1`,
for some set of references `{x1...xn}`. Consider also some predicate
`Q = fun h -> P (sel h y1) ... (sel h yn)`, which is initially true in
`h0`. We would like to prove that if `Q h1` is also true. In other words,
we need to prove the formula:

```
Expanding definitions:
  P (sel h0 y1) ... (sel h0 ym)
  /\ h1 = concat h1 (restrict (complement {x1..xn}) h0)
  ==> P (sel h1 y1) ... (sel h1 ym)
```
In general, for an arbitrary uninterpreted predicate `P`, to prove this,
one must prove an quadratic number of inequalities, e.g., to prove that
`sel h1 y1 = sel h0 y1`, requires proving that `y1` is not equal to any
the `{x1..xn}`.

However, if one can group related references into regions (meaning
related references are generally read and updated together), one can do
much better. For example, moving to hyper-heaps, suppose we place all the
`{x1..xn}` in a region included by `rx`. Suppose `{y1,...,ym}` are all
allocated in some region `ry`. Now, our goal is to prove

```
  P (Heap.sel (Map.sel h0 ry) y1) ... (Heap.sel (Map.sel h0 ry) ym)
  /\ h1 = concat h1 (restrict (mod_set {rx}) h0)
  ==> P (Heap.sel (Map.sel h1 ry) y1) ... (Heap.sel (Map.sel h1 ry) ym)
```

To prove this, we only need to prove that
`Map.sel h0 ry = Map.sel h1 ry`, which involves proving
`not (included rx ry)`. Having proven this fact, the SMT solver simply
unifies the representation of all occurrences of these sub-terms
everywhere in the formula above and concludes the proof immediately.
Thus, in such (arguably common) cases, what initially required quadratic
number of reasoning steps, now only requires a constant number of steps!

In more general scenarios, we may still have to perform a quadratic
number of reasoning steps, but with hyper-heaps, we are quadratic only in
the number of regions involved, which are often _much_ smaller than the
number of references that they may contain. The use of region hierarchies
serves to further reduce the number of region identifiers that one refers
to, making the constants smaller still. Of course, in the degenerate case
where one has just one reference per region, this devolves back to the
performance one would get without regions at all.

<!--

NS: I'm removing this section for the moment. It involves explain
a third model of the heap, augmented with permissions to deal with information
hiding etc. This is getting to be extremely advanced, particularly as it also involves
reasoning about existentially quantified invariant predicates. It was nice to have
as a placeholder when it was the only non-trivial stateful example available in the tutorial.
But, that's no longer the case. We could restore it at some point, with a full explanation
of the permission model etc., if we think that would be useful.

## Local state in two counters

In this simple example with two counters we show how to maintain useful
invariants about the heap.

We define an auxiliary effect `InvST` that maintains the invariant `inv`.

```
effect InvST (t:Type) (inv:(heap -> Type)) (fp:set aref) (post:(heap -> t -> heap -> Type)) =
             ST t (fun h -> On fp inv h)
                  (fun h i h' -> post h i h' /\ On fp inv h')
                  (SomeRefs fp)
```

The two counters will be updated simultaneously, such that their sum is
always even. This requirement is expressed using the type `even` and
`even_post` when liftet to the post condition of a stateful function.

```
type even (x:int) = x%2=0
type even_post (h:heap) (i:int) (h':heap) = even i
```

The following invariant states that the counters are allocated and synchronized.
```
opaque type inv1 (r1:ref int) (r2:ref int) (h:heap) =
           Heap.sel h r1 = Heap.sel h r2
           /\ contains h r1
           /\ contains h r2
```

We will employ two techniques to prove that the invariant is maintained.

 * First, by proving that `r1` and `r2` are incremented by the same amount.
 * Second, using alias analysis by proving that `r1` and `r2` are not changed at all.


```
type t =
  | Evens : inv:(heap -> Type)
          -> fp:set aref
          -> (unit -> InvST int inv fp even_post)
          -> t



val mk_counter: unit
             -> ST t (requires (fun h -> True))
                     (ensures  (fun h v h' ->
                             On  (Evens.fp v) (Evens.inv v) h'
                             /\ Heap.fresh h (Evens.fp v)))
                     (modifies no_refs)
let mk_counter _ =
  let x = ST.alloc 0 in
  let y = ST.alloc 0 in
  let evens () =
    let rx = ST.read x in
    let ry = ST.read y in
    ST.write x (rx + 1);
    ST.write y (ry + 1);
    rx + ry in
  Evens (inv1 x y) (Set.union (Set.singleton (Ref x)) (Set.singleton (Ref y))) evens


val mk_counter_2: unit
               -> ST t (requires (fun h -> True))
                       (ensures  (fun h v h' ->
                         On  (Evens.fp v) (Evens.inv v) h'
                         /\ Heap.fresh h (Evens.fp v)))
                       (modifies no_refs)
let mk_counter_2 _ =
  let x = ST.alloc 0 in
  let evens = fun _ ->
    let rx = ST.read x in
    ST.write x (rx + 1);
    2 * rx in
  Evens (fun h -> b2t(contains h r)) (Set.singleton (Ref x)) evens
```

~Exercise
Fix this example.

~~ ExerciseFragment {exname=ex10b-evens}
val mk_counter_2: unit
               -> ST t (requires (fun h -> True))
                       (ensures  (fun h v h' ->
                         On  (Evens.fp v) (Evens.inv v) h'
                         /\ Heap.fresh h (Evens.fp v)))
                       (modifies no_refs)
let mk_counter_2 _ =
  let x = ST.alloc 0 in
  let evens = fun _ ->
    let rx = ST.read x in
    ST.write x (rx + 1);
    2 * rx in
  Evens (fun h -> b2t(contains h r)) (Set.singleton (Ref x)) evens
~~

~
-->

# Cryptography examples

## MAC

We begin with our cryptographic library.

```
module MAC
open Array
open SHA1
```

Message authentication codes
(MACs) provide integrity protection based on keyed cryptographic hashes.
We define an F* module that implements this functionality.

We attach an authenticated property to each key
used as a pre-condition for MACing and a postcondition of MAC verification.

```
opaque type key_prop : key -> text -> Type
type pkey (p:(text -> Type)) = k:key{key_prop k == p}
```

(In the RPC example below we will use a key of type `pkey reqresp` where
```
opaque logic type reqresp (msg:text) =
    (exists s. msg = request s /\ Request s)
 \/ (exists s t. msg = response s t /\ Response s t)
```
)

Next, we define the types of functions that a MAC library is supposed to
provide:

```
val keygen: p:(text -> Type) -> pkey p
val mac:    k:key -> t:text{key_prop k t} -> tag
val verify: k:key -> t:text -> tag -> b:bool{b ==> key_prop k t}
```

## Cryptographic Capabilities for Accessing Files

We extend the acls2.fst example with cryptographic capabilities, so
that our trusted ACLs library can now issue and accept HMACSHA1 tags
as evidence that a given file is readable.

What is the advantage of capabilities over the refinements already
provided in acls2.fst?

~ Exercise
Relying on acls2.fst and mac.fst, implement a pair of functions with
the following specification, and verify them by typing under the
security assumption that HMACSHA1 is INT-CPA.

~~ CodeFragment {filename=exercises/acls-cap.fst name=ex12a-acls-cap}
val issue:  f:file{ canRead f } -> SHA1.tag
val redeem: f:file -> m:SHA1.tag -> u:unit{ canRead f }
~~

To this end, assume given a UTF8 encoding function from strings to
bytes, with the following specification:

```
assume val utf8: s:string  -> Tot (seq byte)

assume UTF8_inj:
  forall s0 s1.{:pattern (utf8 s0); (utf8 s1)}
    equal (utf8 s0) (utf8 s1) ==> s0==s1


```

~~ Answer
```
val issue: f:file{ canRead f } -> SHA1.tag
val redeem: f:file -> m:SHA1.tag -> u:unit{ canRead f }

let issue f = MAC.mac k (utf8 f)
let redeem f t = if MAC.verify k (utf8 f) t then () else failwith "bad capability"

```
~~

How would we extend it to also cover CanWrite access?
~

## Secure RPC

We describe a simple secure RPC implementation, which consists of three
modules: `Mac`, our library for MACs, `Format`, a module for message
formatting, and `RPC`, a module for the rest of the protocol code.
(Placing the formatting functions request and response in a separate
module is convenient to illustrate modular programming and verification.)

### Secure RPC protocol

To start with we consider a single client and server. The security goals of
our RPC protocol are that (1) whenever the server accepts a
request message `s` from the client, the client has indeed sent the message to
the server and, conversely,
(2) whenever the client accepts a response message `t` from the server,
the server has indeed sent the
message in response to a matching request from the client.

To this end, the protocol uses message authentication codes (MACs) computed as
keyed hashes, such that each symmetric MAC key kab is associated with (and known
to) the pair of principals a and b. Our protocol may be informally described as follows.
An Authenticated RPC Protocol:

    1. client->server  utf8 s | (mac kab (request s))
    2. server->client  utf8 t | (mac kab (response s t))

In the protocol narration, each line indicates an intended communication of data
from one principal to another.

`utf8` marshalls strings such as `s` and `t` into byte arrays
that can be send over the network. `|` written also `append`
is a function concatenating `bytes`. `request` and `response` build
message digests (the authenticated values). These functions may for
instance be implemented as tagged concatenations of their utf8-encoded
arguments. These functions will be detailed in the `Format` module.

Below we give an implementation of the protocol using these functions,
the functions of the 'Mac' module, and networking functions

```
assume val send: message -> unit
assume val recv: (message -> unit) -> unit
```

These functions model an untrusted network controlled by the adversary, who decides
through their implementation when to deliver messages.

Two events, record genuine requests and responses
```
logic type Request : string -> Type
logic type Response : string -> string -> Type
```
in the following protocol

```
let client (s:string16) =
  assume (Request s);
  send (append (utf8 s) (mac k (request s)));
  recv (fun msg ->
    if length msg < macsize then failwith "Too short"
    else
      let (v, m') = split msg (length msg - macsize) in
      let t = iutf8 v in
      if verify k (response s t) m'
      then assert (Response s t))

let server () =
  recv (fun msg ->
    if length msg < macsize then failwith "Too short"
    else
      let (v,m) = split msg (length msg - macsize) in
      if length v > 65535 then failwith "Too long"
      else
        let s = iutf8 v in
        if verify k (request s) m
        then
          ( assert (Request s);
            let t = "22" in
            assume (Response s t);
            send (append (utf8 t) (mac k (response s t)))))
```

The `assert` guarantee that messages that are received by a party have been sent by its peer.

### Formating code

The Format module used by the protocol implementation
exports among others the following types and functions.

```
type message = seq byte
type msg (l:nat) = m:message{length m==l}

val request : string -> Tot message
let request s = append tag0 (utf8 s)

val response: string16 -> string -> Tot message
let response s t =
  let lb = uint16_to_bytes (length (utf8 s)) in
  append tag1 (append lb (append (utf8 s) (utf8 t)))
```

We require 3 lemmas on message formats:

* requests are injective on their argument
* responses are injective on both their arguments
* requests and responses are distinct

For authentication properties, we require both functions to be
injective, so that authenticating the bytes unambiguously
authenticate the text before marshalling.

~Exercise
Try to state this formally as three lemmas.


~~Answer
```
val req_resp_distinct:
  s:string -> s':string16 -> t':string ->
  Lemma (requires True)
        (ensures (request s <> response s' t'))
        [SMTPat (request s); SMTPat (response s' t')]

val req_components_corr:
  s0:string -> s1:string ->
  Lemma (requires (request s0 == request s1))
        (ensures  (s0==s1))

val resp_components_corr:
  s0:string16 -> t0:string -> s1:string16 -> t1:string ->
  Lemma (requires (response s0 t0 == response s1 t1))
        (ensures  (s0==s1 /\ t0==t1))
```
~~
~

~ Exercise
Prove these three lemmas.
~

~~ Answer
```
let req_resp_distinct s s' t' =
  assert (Array.index (request s) 0 <> Array.index (response s' t') 0)
let req_components_corr s0 s1 = ()
let resp_components_corr s0 t0 s1 t1 = ()
```
~~

<!--
These lemmas rely on more powerful lemmas about the
injectivity of append:

```
val append_inj: #l:nat
               -> b1:msg l -> b2:message
               -> c1:msg l -> c2:message{append b1 b2==append c1 c2}
               -> Lemma (ensures (equal b1 c1 /\ equal b2 c2))

val append_inj_lemma: b1:message -> b2:message
                   -> c1:message -> c2:message
                   -> Lemma (requires (length b1==length c1 /\ append b1 b2==append c1 c2))
                            (ensures (equal b1 c1 /\ equal b2 c2))
                            (decreases (length b1))
                            [SMTPat (append b1 b2); SMTPat (append c1 c2)]
```

~ Exercise
The proof of the second lemma contain currently contains an 'admit'.
Try to fix this proof.
~

~~ Answer
```
let rec append_inj_lemma b1 b2 c1 c2 =
  let l = length b1 in
  match l with
  | 0 -> ()
  | _ -> append_inj_lemma (slice b1 1 l) b2 (slice c1 1 l) c2
```
~~
-->

~ Remark
In the lecture we also saw an extended protocol where we have a
population of principals, represented as concrete strings ranged over
by a and b, that intend to perform various remote procedure calls
(RPCs) over a public network.
The RPCs consist of requests and responses, both also represented as strings.
The security goals of our RPC protocol are that (1) whenever a principal b accepts a
request message s from a, principal a has indeed sent the message to b and, conversely,
(2) whenever a accepts a response message t from b, principal b has indeed sent the
message in response to a matching request from a.
~

<!--
## Signing Email

The purpose of this exercise is to program and verify functions for
signing email messages and verifying their signatures.
-->

## Verified Padding

We intend to MAC and/or encrypt plaintexts of variable sizes using
fixed-sized algorithms, such as those that operate on 256-bit blocks, such as AES.

To this end, we use the following classic padding scheme (used for instance in TLS).

```
module Pad
open Array

(* two coercions from uint8 <--> n:int { 0 <= n < 255 } *)
assume val n2b: n:nat {( n < 256 )} -> Tot uint8
assume val b2n: b:uint8 -> Tot (n:nat { (n < 256) /\ n2b n = b })

type bytes = seq byte (* concrete byte arrays *)
type nbytes (n:nat) = b:bytes{length b == n} (* fixed-length bytes *)

let blocksize = 32
type block = nbytes blocksize
type text = b:bytes {(length b < blocksize)}

let pad n = Array.create n (n2b (n-1))

let encode (a:text) = append a (pad (blocksize - length a))

let decode (b:block) =
  let padsize = b2n(index b (blocksize - 1)) + 1 in
  if op_LessThan padsize blocksize then
    let (plain,padding) = split b (blocksize - padsize) in
    if padding = pad padsize
    then Some plain
    else None
  else None
```

~ Exercise
What do these function do? Write as precise as possible
typed specifications for these functions. In particular
show that decoding cancels out encoding.

~~ Answer

```
val pad: n:nat { 1 <= n /\ n <= blocksize } -> Tot (nbytes n)
val encode: a: text -> Tot block
val decode: b:block -> Tot (option (t:text { Array.equal b (encode t)}))
```
~~
~


~ Exercise
Is it a good padding scheme? What are its main properties?

Prove a lemma that expresses its injectivity.

Provide examples of other schemes, both good and bad.

~~ Answer

A padding scheme should be invertible. For authentication properties,
we require it to be injective, so that authenticating a padded text
unambiguously authenticate the text before padding. For instance:

```
val inj: a: text -> b: text -> Lemma (requires (Array.equal (encode a) (encode b)))
                                     (ensures (Array.equal a b))
                                     [SMTPat (encode a); SMTPat (encode b)]
                                     (decreases (length a))
let inj a b =
  if length a = length b
  then ()
  else let aa = encode a in
       let bb = encode b in
       cut (Array.index aa 31 =!= Array.index bb 31)
```

In this context, another good padding scheme is to append a 1 then
enough zeros to fill the block. One could also format the message by
explicitly including its length.
A bad scheme is to fill the rest of the block with zeros (or random
values), as the same padded text may then be parsed into several texts
ending with 0s.
~~
~

~ Exercise
Relying on that specification, implement and verify a MAC interface
for messages of type `text`, i.e., of less than `blocksize` bytes,
using the MAC interface below, which only supports messages of type
`block`.

To this end, we assume given an implementation of the following module
(adapted from `mac.fst`)

```
module BMAC
open Pad

let keysize = 16 (* these are the sizes for SHA1 *)
let macsize = 20
type key = nbytes keysize
type tag = nbytes macsize

opaque type key_prop : key -> block -> Type
type pkey (p:(block -> Type)) = k:key{key_prop k == p}

assume val keygen: p:(block -> Type) -> pkey p
assume val mac:    k:key -> t:block{key_prop k t} -> tag
assume val verify: k:key -> t:block -> tag -> b:bool{b ==> key_prop k t}
```

Write a similar module that accepts texts instead of blocks:
first the implementations for keygen, mac, and verify,
then type annotations to derive their authentication property
(on texts) from the one of BMAC (on blocks).

~~ Answer
```
module TMAC
open Pad

let keysize = BMAC.keysize
let macsize = BMAC.macsize
type key = BMAC.key
type tag = BMAC.tag

opaque type bspec (spec: (text -> Type)) (b:block) =
  (forall (t:text). b = encode t ==> spec t)

opaque type key_prop : key -> text -> Type
type pkey (p:(text -> Type)) =
  k:key{key_prop k == p /\ BMAC.key_prop k == bspec p}

val keygen: p:(text -> Type) -> pkey p
val mac:    p:(text -> Type) -> k:pkey p -> t:text{p t} -> tag
val verify: p:(text -> Type) -> k:pkey p -> t:text -> tag -> b:bool{b ==> p t}

let keygen (spec: text -> Type) =
  let k = BMAC.keygen (bspec spec) in
  assume (key_prop k == spec);
  k

let mac (p:text -> Type) k t = BMAC.mac k (encode t)
let verify k t tag = BMAC.verify k (encode t) tag
```
~~
~

~ Exercise
(1) Can we similarly construct a MAC scheme for texts
    with type `text:bytes {length text <= n}`?
(2) Implement, then verify this construction.

~~ Answer
(1) Yes, using two keys: one for `text:bytes {length b = n}`
and another for `text:bytes {length b}`.

(2) Code:
```
module MAC2
open Array
open Pad

type text2 = b:bytes { length b <=  blocksize }

let keysize = 2 * BMAC.keysize
let macsize = BMAC.macsize
type key = | Keys: k0:BMAC.key -> k1:BMAC.key -> key
type tag = BMAC.tag

opaque type bspec0 (spec: (text2 -> Type)) (b:block) =
  (forall (t:text). b = encode t ==> spec t)

opaque type bspec1 (spec: (text2 -> Type)) (b:block) =
  spec b

opaque type key_prop : key -> text2 -> Type

type pkey (p:(text2 -> Type)) =
  k:key{ key_prop k == p
      /\ BMAC.key_prop (Keys.k0 k) == bspec0 p
      /\ BMAC.key_prop (Keys.k1 k) == bspec1 p }

val keygen: p:(text2 -> Type) -> pkey p
val mac:    p:(text2 -> Type) -> k:pkey p -> t:text2{p  t} -> tag
val verify: p:(text2 -> Type) -> k:pkey p -> t:text2 -> tag -> b:bool{b ==> p t}

let keygen (spec: text2 -> Type) =
  let k0 = BMAC.keygen (bspec0 spec) in
  let k1 = BMAC.keygen (bspec1 spec) in
  let k = Keys k0 k1 in
  assert (BMAC.key_prop k0 == bspec0 spec);
  assert (BMAC.key_prop k1 == bspec1 spec);
  assume (key_prop k == spec);
  k

let mac (Keys k0 k1) t =
  if length t < blocksize
  then BMAC.mac k0 (encode t)
  else BMAC.mac k1 t

let verify (Keys k0 k1) t tag =
  if length t < blocksize
  then BMAC.verify k0 (encode t) tag
  else BMAC.verify k1 t tag

```
~~

~

~ Exercise
What about MAC schemes for texts of arbitrary lengths?
Hint: have a look e.g. at the HMAC construction.
~


# Advanced cryptographic examples

## Stateful Authenticated Encryption

A typical guarantee provided by a secure channel protocol is that
messages are received in the same order in which they were sent. To
achieve this, we construct a stateful, authenticated encryption scheme from
a (stateless) “authenticated encryption with additional data” (AEAD)
scheme (Rogaway 2002). Two counters are maintained, one each for the
sender and receiver. When a message is to be sent, the counter value is
authenticated using the AEAD scheme along with the rest of the message
payload and the counter is incremented. The receiver, in turn, checks
that the sender’s counter in the message matches hers each time a message
is received and increments her counter.

Cryptographically, the ideal functionality behind this scheme involves
associating a stateful log with each instance of a encryptor/decryptor
key pair. At the level of the stateless functionality, the guarantee
is that every message sent is in the log and the receiver only accepts
messages that are in the log---no guarantee is provided regarding
injectivity or the order in which messages are received. At the
stateful level, we again associate a log with each key pair and here
we can guarantee that the sends and receives are in injective,
order-preserving correspondence. Proving this requires relating the
contents of the logs at various levels, and, importantly, proving that
the logs associated with different instances of keys do not
interfere. We give this proof in F*.

We start with a few types provided by the `AEAD` functionality.

```
module AEAD
type encryptor = Enc : #r:rid -> log:rref r (seq entry) -> key -> encryptor
and decryptor =  Dec : #r:rid -> log:rref r (seq entry) -> key -> decryptor
and entry =  Entry : ad:nat -> c:cipher -> p:plain -> basicEntry
```

An `encryptor` encapsulates a `key` (an abstract type whose
hidden representation is the raw bytes of a key) with a log of entries
stored in the heap for modeling the ideal
functionality. Each `entry` associates a `plain` text `p`,
with its `cipher` `c` and some additional data `ad:nat`. The
log is stored in a region `r`, which we maintain as an additional
(erasable) field of `Enc`. The `decryptor` is similar. It is
worth pointing out that although `AEAD` is a stateless
functionality, its cryptographic modeling involves the introduction of
a stateful log. Based on a cryptographic assumption, one can view this log as
ghost.

On top of `AEAD`, we add a `Stateful` layer, providing stateful
encryptors and decryptors. `StEnc` encapsulates an encryption key
provided by `AEAD` together with the sender's counter, `ctr`,
and its own log of stateful entries, associates `plain`-texts
with `cipher`s. The `log` and the counter are stored in a
region `r` associated with the stateful encryptor. `StDec` is
analogous.

```
module Stateful
type st_enc = StEnc : #r:rid -> log: rref r (seq st_entry) -> ctr: rref r nat
           -> key:encryptor{extends (Enc.r key) r} -> st_enc
and st_dec =  StDec : #r:rid -> log: rref r (seq st_entry) -> ctr: rref r nat
           -> key:decryptor{extends (Dec.r key) r} -> st_dec
and st_entry = StEntry : c:cipher -> p:plain -> st_entry
```

Exploiting the hierarchical structure of hyper-heaps, we store
the `AEAD.encryptor` in a distinct sub-region of `r`---this is
the meaning of the `extends` relation. By doing this, we ensure
that the state associated with the `AEAD` encryptor is distinct
from both `log` and `ctr`. By allocating distinct instances
`k1` and `k2` in disjoint regions, we can prove that using
`k1` (say `decrypt k1 c`) does not alter the state
associated with `k2`. In this simplified setting with just three
references, the separation provided is minimal; when manipulating
objects with sub-objects that contain many more references (as in our
full development), partitioning them into separate regions provides
disequalities between their references for free.


~ Exercise
Look at the following code, what happens in case of decryption failure?

~~ CodeFragment {filename=exercises/stateful-encrypt.fst name=ex13a-stateful-encrypt}
type statefulEntry =
  | StEntry : c:cipher -> p:plain -> statefulEntry

type st_encryptor (i:rid) =
  | StEnc : log: rref i (seq statefulEntry) ->
            ctr: rref i nat ->
            key:encryptor i ->
            st_encryptor i

type st_decryptor (i:rid) =
  | StDec : log: rref i (seq statefulEntry) ->
            ctr: rref i nat ->
            key:decryptor i ->
            st_decryptor i

  ...

val stateful_enc : #i:rid -> e:st_encryptor i -> p:plain -> ST cipher
  (requires (fun h -> st_enc_inv e h))
  (ensures (fun h0 c h1 ->
            st_enc_inv e h1
         /\ HyperHeap.modifies (Set.singleton i) h0 h1
         /\ Heap.modifies (refs_in_e e) (Map.sel h0 i) (Map.sel h1 i)
         /\ sel h1 (StEnc.log e) = snoc (sel h0 (StEnc.log e)) (StEntry c p)))
let stateful_enc i (StEnc log ctr e) p =
    let c = enc e (op_Bang ctr) p in
    op_Colon_Equals log (snoc (op_Bang log) (StEntry c p));
    op_Colon_Equals ctr (op_Bang ctr + 1);
    c

val stateful_dec: #i:rid -> d:st_decryptor i -> c:cipher -> ST (option plain)
  (requires (fun h -> st_dec_inv d h))
  (ensures (fun h0 p h1 ->
        st_dec_inv d h0    //repeating pre
        /\ st_dec_inv d h1
        /\ HyperHeap.modifies (Set.singleton i) h0 h1
        /\ Heap.modifies !{as_ref (StDec.ctr d)} (Map.sel h0 i) (Map.sel h1 i)
        /\ Let (sel h0 (StDec.ctr d)) (fun (r:nat{r=sel h0 (StDec.ctr d)}) ->
           Let (sel h0 (StDec.log d))
           (fun (log:seq statefulEntry{log=sel h0 (StDec.log d)}) ->
           (is_None p ==> (r = Seq.length log           //nothing encrypted yet
                          || StEntry.c (Seq.index log r) <> c //wrong cipher
                            ) /\ sel h1 (StDec.ctr d) = r)
        /\ (is_Some p ==>
                  ((sel h1 (StDec.ctr d) = r + 1)
                   /\ StEntry.p (Seq.index log r) = Some.v p))))))

let stateful_dec _id (StDec _ ctr d) c =
  let i = op_Bang ctr in
  cut(trigger i);
  match dec d (op_Bang ctr) c with
    | None -> None
    | Some p -> op_Colon_Equals ctr (op_Bang ctr + 1); Some p

~~

~

## Encryption

Next we will look into constructing basic encryption schemes from even lower
level cryptographic primitives.

The basis of our first encryption example is the interface of a symmetric
encryption scheme based on a block cipher, say AES.
It uses a one block initialization vector (IV) that is XORed to the plaintext.
The masked value is then enciphered. The ciphertext consists of the IV and this
enciphered block.

```
module AES
open Array

type bytes = seq byte
type nbytes (n:nat) = b:bytes{length b == n}

let blocksize = 32 (* 256 bits *)

type plain  = nbytes blocksize
type cipher = nbytes (2 * blocksize)  (* including IV *)

let keysize = 16 (* 128 bits *)
type key = nbytes keysize

assume val gen: unit -> key
assume val dec: key -> cipher -> Tot plain
(* this function is pure & complete *)
assume val enc: k:key -> p:plain -> c:cipher
```

~ Exercise
Refine the type of the encryption function to model the *correctness* property:
A correctly generated ciphertext, decrypts to its plaintext.
~~ CodeFragment {filename=exercises/encrypt.fst name=ex13a-encrypt}
assume val enc: k:key -> p:plain -> c:cipher
~~

~~ Answer

```
assume val enc: k:key -> p:plain -> c:cipher{ dec k c = p }
(* this function is not pure (samples IV);
   the refinement captures functional correctness *)
```
~~

~

We model *perfect secrecy* by typing using type abstraction. As concrete cryptographic
algorithms such as the one above talk about bytes, we now introduce the notion of a
symmetric encryption scheme that enforces type abstraction for `safe` keys.

A scheme is parameterized by a key type `k` for keys and a plain type `p` that abstractly defines plaintexts.

Keys are abstract to enforce a well typed key usage regime on well typed users of the module.

```
module SymEnc (* a multi-key symmetric variant; for simplicity:
                 (1) only using AES above; and (2) parsing is complete *)

type r = AES.plain

(* CPA variant: *)
opaque type Encrypted: #k: Type -> p:Type -> k -> AES.bytes -> Type
(* an opaque predicate, keeping track of honest encryptions *)

type cipher (p:Type) (k:Type) (key:k) = c:AES.cipher { Encrypted p key c }
```
The type of `cipher` records the plain type, key type, and key it was generated for.

```
type keyT: Type -> Type =
  | Ideal    : p:Type -> AES.key -> i:int -> keyT p
  | Concrete : p:Type -> AES.key -> i:int -> keyT p
```
Keys record whether they were correctly generated `Ideal` in which
case their usage will provide security by type abstraction, or not, in
which they are just concrete keys that can be leaked to the adversary.

```
type scheme: Type -> Type =
  | Scheme:  p:Type -> k:Type ->
             keyrepr: (k -> AES.key) ->
             keygen:  (bool -> k) ->
             encrypt: (key:k -> p -> cipher p k key) ->
             decrypt: (key:k -> cipher p k key -> p) ->
             scheme p
```

A scheme records a plain type `p`, a function `keyrepr` for breaking
key abstraction, a key generation function `keygen`, and encryption
and decryption functions `encrypt` and `decrypt`.

```
type entry (p:Type) (k:Type) =
  | Entry : key:k -> c:cipher p k key -> plain:p -> entry p k

```


To create a cryptographic scheme one needs to provide a `plain` function
for turning `bytes` into the plain type values
and a `repr` function for turning plain type values into bytes.
```
val create: p: Type -> plain: (r -> p) -> repr: (p -> r) -> scheme p
```

The `create` function instantiates the scheme using the `AES` module.

```
let create (p:Type) plain repr =
  let c = ST.alloc 0 in
  let log : ref (list (entry p (keyT p))) = ST.alloc [] in

  let keygen : bool -> keyT p = fun safe ->
    let i = !c in
    c := !c + 1;
    let kv = AES.gen() in
    if safe
    then Ideal    p kv i
    else Concrete p kv i in

  let keyrepr k : AES.key =
    match k with
    | Ideal kv _ -> failwith "no way!"
    | Concrete kv _ -> kv in

  let encrypt: (k:keyT p -> p -> cipher p (keyT p) k) = fun k text ->
    match k with
    | Ideal kv _ ->
       let c = AES.enc kv AES.dummy in
       assume (Encrypted p k c);
       log := Entry k c text :: !log;
       c

    | Concrete kv _ ->
       let rep = repr text in
       (* NS: need the let-binding because repr is impure and we can't
          substitute it in the type of 'enc' *)
       let c = AES.enc kv rep in
       assume (Encrypted p k c);
       c in

  let decrypt: key:keyT p -> cipher p (keyT p) key -> p = fun k c ->
    match k with
    | Ideal kv _ -> (match List.find (fun (Entry k' c' _) -> k=k' && c= c') !log with
                     | Some e -> Entry.plain e
                     | _ -> failwith "never")
    | Concrete kv _ -> plain (AES.dec kv c)  in

  Scheme p (keyT p) keyrepr keygen encrypt decrypt
```

Relying on basic cryptographic assumptions (IND-CPA), the
 ideal implementation never accesses plaintexts when using `Ideal` keys!

Formally, the `Ideal` branch can be typed using an abstract plaintype:
`encrypt` encrypts a constant AES block `c` and logs `Entry k c text`
`decrypt` returns `text` when `Entry k c text` is in the log.
As IND-CPA requires that only ciphertext that have previously
been encrypted are decrypted, this is guaranteed by typing to be always the case.

Here is how such a symmetric encryption scheme would be used in an example:
```
module SampleEncrypt
open SymEnc
let plain (x:AES.plain) = x
let repr (x:AES.plain) = x

let test() =
  let p = failwith "nice bytes" in
  let Scheme keyrepr keygen encrypt decrypt = SymEnc.create (AES.plain) plain repr in
  let k0 = keygen true in
  let k1 = keygen true in
  let c = encrypt k0 p in
  let p' = decrypt k0 c in
  assert( p == p');                // this succeeds, as we enforce functional correctness
  (* let p'' = decrypt k1 c in     // this rightfully triggers an error *)
  ()
```

[Title          A]: http://Title_A.com "Title          A title"


<script>
// show answers when clicked upon.
[].forEach.call( document.getElementsByClassName("answer-link"), function(answerLink) {
  answerLink.addEventListener("click", function(ev) {
    var answer = answerLink.parentNode;
    var cls = answer.className;
    if (/\bview\b/.test(cls)) {
      answer.className = cls.replace(/\s*view\s*/,"");
    }
    else {
      answer.className = cls + " view";
    }
  });
});
</script>
